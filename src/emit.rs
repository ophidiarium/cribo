use anyhow::{Context, Result};
use regex::Regex;
use rustpython_parser::ast::{Suite, Stmt, StmtImport, StmtImportFrom};
use rustpython_parser::Parse;
use std::collections::HashSet;
use std::fs;
use std::path::Path;

use crate::dependency_graph::ModuleNode;
use crate::resolver::{ImportType, ModuleResolver};

pub struct CodeEmitter {
    resolver: ModuleResolver,
    preserve_comments: bool,
    preserve_type_hints: bool,
}

impl CodeEmitter {
    pub fn new(resolver: ModuleResolver, preserve_comments: bool, preserve_type_hints: bool) -> Self {
        Self {
            resolver,
            preserve_comments,
            preserve_type_hints,
        }
    }
    
    /// Generate bundled Python code from sorted modules
    pub fn emit_bundle(&mut self, modules: &[&ModuleNode], entry_module: &str) -> Result<String> {
        let mut output = Vec::new();
        
        // Add header comment
        output.push("#!/usr/bin/env python3".to_string());
        output.push("# Generated by Serpen - Python Source Bundler".to_string());
        output.push("# https://github.com/tinovyatkin/serpen".to_string());
        output.push("".to_string());
        
        // Collect all third-party imports that need to be preserved
        let mut third_party_imports = HashSet::new();
        let mut stdlib_imports = HashSet::new();
        
        for module in modules {
            for import in &module.imports {
                match self.resolver.classify_import(import) {
                    ImportType::ThirdParty => {
                        third_party_imports.insert(import.clone());
                    }
                    ImportType::StandardLibrary => {
                        stdlib_imports.insert(import.clone());
                    }
                    ImportType::FirstParty => {
                        // Will be inlined, so skip
                    }
                }
            }
        }
        
        // Add preserved imports at the top
        if !stdlib_imports.is_empty() || !third_party_imports.is_empty() {
            output.push("# Preserved imports".to_string());
            
            // Standard library imports first
            let mut sorted_stdlib: Vec<_> = stdlib_imports.into_iter().collect();
            sorted_stdlib.sort();
            for import in &sorted_stdlib {
                output.push(format!("import {}", import));
            }
            
            if !sorted_stdlib.is_empty() && !third_party_imports.is_empty() {
                output.push("".to_string());
            }
            
            // Third-party imports
            let mut sorted_third_party: Vec<_> = third_party_imports.into_iter().collect();
            sorted_third_party.sort();
            for import in sorted_third_party {
                output.push(format!("import {}", import));
            }
            
            output.push("".to_string());
        }
        
        // Process each module in dependency order
        for module in modules {
            // Skip entry module for now - we'll add it at the end
            if module.name == entry_module {
                continue;
            }
            
            output.push(format!("# ─ Module: {} ─", module.name));
            
            let module_code = self.process_module_file(&module.path, &module.name)?;
            output.push(module_code);
            output.push("".to_string());
        }
        
        // Add entry module last
        if let Some(entry_module_node) = modules.iter().find(|m| m.name == entry_module) {
            output.push(format!("# ─ Entry Module: {} ─", entry_module));
            let entry_code = self.process_module_file(&entry_module_node.path, &entry_module_node.name)?;
            output.push(entry_code);
        }
        
        Ok(output.join("\n"))
    }
    
    /// Process a single module file, removing inlined imports
    fn process_module_file(&mut self, file_path: &Path, _module_name: &str) -> Result<String> {
        let source = fs::read_to_string(file_path)
            .with_context(|| format!("Failed to read module file: {:?}", file_path))?;
        
        // Simple approach: process line by line and filter out first-party imports
        let mut output_lines = Vec::new();
        
        for line in source.lines() {
            let trimmed = line.trim();
            
            // Check if this is an import line
            if trimmed.starts_with("from ") && trimmed.contains(" import ") {
                // Parse "from module import ..."
                if let Some(module_part) = trimmed.strip_prefix("from ").and_then(|s| s.split(" import ").next()) {
                    let module_name = module_part.trim();
                    match self.resolver.classify_import(module_name) {
                        ImportType::FirstParty => {
                            // Skip first-party imports - they'll be inlined
                            continue;
                        }
                        ImportType::ThirdParty | ImportType::StandardLibrary => {
                            // Keep third-party and stdlib imports
                            output_lines.push(line.to_string());
                        }
                    }
                } else {
                    // Keep malformed import lines as-is
                    output_lines.push(line.to_string());
                }
            } else if trimmed.starts_with("import ") {
                // Parse "import module"
                let imports_part = trimmed.strip_prefix("import ").unwrap();
                let modules: Vec<&str> = imports_part.split(',').map(|s| s.trim()).collect();
                
                let mut keep_line = false;
                for module in modules {
                    // Handle "import module as alias"
                    let module_name = module.split(" as ").next().unwrap_or(module).trim();
                    match self.resolver.classify_import(module_name) {
                        ImportType::ThirdParty | ImportType::StandardLibrary => {
                            keep_line = true;
                            break;
                        }
                        ImportType::FirstParty => {
                            // Continue checking other modules in the same line
                        }
                    }
                }
                
                if keep_line {
                    output_lines.push(line.to_string());
                }
                // Skip lines with only first-party imports
            } else {
                // Keep all non-import lines
                output_lines.push(line.to_string());
            }
        }
        
        Ok(output_lines.join("\n"))
    }
    
    /// Process statements to remove inlined imports
    fn process_statements(&mut self, statements: &[Stmt], module_name: &str) -> Result<Vec<Stmt>> {
        let mut processed = Vec::new();
        
        for stmt in statements {
            match stmt {
                Stmt::Import(import_stmt) => {
                    // Check if any of the imports should be preserved
                    let mut preserved_names = Vec::new();
                    
                    for name in &import_stmt.names {
                        let import_name = name.name.as_str();
                        match self.resolver.classify_import(import_name) {
                            ImportType::FirstParty => {
                                // Skip first-party imports - they'll be inlined
                            }
                            ImportType::ThirdParty | ImportType::StandardLibrary => {
                                preserved_names.push(name.clone());
                            }
                        }
                    }
                    
                    // Only keep the statement if there are preserved imports
                    if !preserved_names.is_empty() {
                        let new_stmt = Stmt::Import(StmtImport {
                            names: preserved_names,
                            range: import_stmt.range.clone(),
                        });
                        processed.push(new_stmt);
                    }
                }
                Stmt::ImportFrom(import_from_stmt) => {
                    if let Some(ref module_name) = import_from_stmt.module {
                        let module_str = module_name.as_str();
                        match self.resolver.classify_import(module_str) {
                            ImportType::FirstParty => {
                                // Skip first-party imports - they'll be inlined
                            }
                            ImportType::ThirdParty | ImportType::StandardLibrary => {
                                processed.push(stmt.clone());
                            }
                        }
                    } else {
                        // Relative imports - keep them for now
                        processed.push(stmt.clone());
                    }
                }
                _ => {
                    // Keep all other statements
                    processed.push(stmt.clone());
                }
            }
        }
        
        Ok(processed)
    }
    
    /// Convert AST statement back to string (simplified)
    fn statement_to_string(&self, stmt: &Stmt) -> Result<String> {
        // This is a simplified implementation
        // In a full implementation, you'd want to use a proper Python code formatter
        match stmt {
            Stmt::Import(import_stmt) => {
                let import_names: Vec<String> = import_stmt.names
                    .iter()
                    .map(|name| {
                        if let Some(ref asname) = name.asname {
                            format!("{} as {}", name.name.as_str(), asname.as_str())
                        } else {
                            name.name.as_str().to_string()
                        }
                    })
                    .collect();
                Ok(format!("import {}", import_names.join(", ")))
            }
            Stmt::ImportFrom(import_from_stmt) => {
                let module_part = if let Some(ref module) = import_from_stmt.module {
                    let level_dots = if let Some(ref level) = import_from_stmt.level {
                        ".".repeat(level.to_usize())
                    } else {
                        String::new()
                    };
                    format!("{}{}", level_dots, module.as_str())
                } else {
                    let level_num = if let Some(ref level) = import_from_stmt.level {
                        level.to_usize()
                    } else {
                        0
                    };
                    ".".repeat(level_num)
                };
                
                let import_names: Vec<String> = import_from_stmt.names
                    .iter()
                    .map(|name| {
                        if let Some(ref asname) = name.asname {
                            format!("{} as {}", name.name.as_str(), asname.as_str())
                        } else {
                            name.name.as_str().to_string()
                        }
                    })
                    .collect();
                
                Ok(format!("from {} import {}", module_part, import_names.join(", ")))
            }
            _ => {
                // For other statements, we'd need a more sophisticated approach
                // For now, return a placeholder that indicates we need the original source
                Ok("# [Statement preserved from original source]".to_string())
            }
        }
    }
    
    /// Generate requirements.txt content from third-party imports
    pub fn generate_requirements(&mut self, modules: &[&ModuleNode]) -> Result<String> {
        let mut third_party_imports = HashSet::new();
        
        for module in modules {
            for import in &module.imports {
                if let ImportType::ThirdParty = self.resolver.classify_import(import) {
                    // Extract top-level package name
                    let package_name = import.split('.').next().unwrap_or(import);
                    third_party_imports.insert(package_name.to_string());
                }
            }
        }
        
        let mut requirements: Vec<String> = third_party_imports.into_iter().collect();
        requirements.sort();
        
        Ok(requirements.join("\n"))
    }
}
