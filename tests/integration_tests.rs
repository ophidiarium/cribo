use std::path::PathBuf;
use tempfile::TempDir;

use serpen::bundler::Bundler;
use serpen::config::Config;

#[test]
fn test_simple_project_bundling() {
    // Initialize logger for debugging
    let _ = env_logger::try_init();
    
    let mut config = Config::default();
    // Set src to the test fixture directory
    config.src = vec![PathBuf::from("tests/fixtures/simple_project")];
    let mut bundler = Bundler::new(config);
    
    // Create temporary output directory
    let temp_dir = TempDir::new().unwrap();
    let output_path = temp_dir.path().join("bundle.py");
    
    // Path to our test fixture
    let entry_path = PathBuf::from("tests/fixtures/simple_project/main.py");
    
    // Skip if test fixture doesn't exist (for CI environments)
    if !entry_path.exists() {
        return;
    }
    
    // Test bundling
    let result = bundler.bundle(&entry_path, &output_path, false);
    
    match result {
        Ok(()) => {
            // Verify output file exists
            assert!(output_path.exists());
            
            // Verify output contains expected content
            let content = std::fs::read_to_string(&output_path).unwrap();
            println!("=== BUNDLED CONTENT ===");
            println!("{}", content);
            println!("=== END BUNDLED CONTENT ===");
            
            // Check for basic structure
            assert!(content.contains("# Generated by Serpen"));
            
            // Check for module content
            if !content.contains("def greet") {
                panic!("Bundle missing 'def greet' function from utils.helpers");
            }
            if !content.contains("class User") {
                panic!("Bundle missing 'class User' from models.user");
            }
            
            println!("Bundle test passed!");
        }
        Err(e) => {
            eprintln!("Bundle test failed: {}", e);
            // Print more error details
            println!("Full error chain:");
            let mut source = e.source();
            while let Some(err) = source {
                println!("  Caused by: {}", err);
                source = err.source();
            }
            panic!("Bundling failed: {}", e);
        }
    }
}

#[test]
fn test_requirements_generation() {
    let config = Config::default();
    let mut bundler = Bundler::new(config);
    
    // Create temporary output directory
    let temp_dir = TempDir::new().unwrap();
    let output_path = temp_dir.path().join("bundle.py");
    
    // Path to our test fixture with third-party dependencies
    let entry_path = PathBuf::from("tests/fixtures/pydantic_project/main.py");
    
    // Skip if test fixture doesn't exist
    if !entry_path.exists() {
        return;
    }
    
    // Test bundling with requirements generation
    let result = bundler.bundle(&entry_path, &output_path, true);
    
    match result {
        Ok(()) => {
            // Verify requirements.txt was created
            let requirements_path = temp_dir.path().join("requirements.txt");
            if requirements_path.exists() {
                let requirements = std::fs::read_to_string(&requirements_path).unwrap();
                println!("Generated requirements:\n{}", requirements);
            }
        }
        Err(e) => {
            eprintln!("Requirements test failed: {}", e);
        }
    }
}

#[test]
fn test_module_resolution() {
    use serpen::config::Config;
    use serpen::resolver::ModuleResolver;
    
    let mut config = Config::default();
    config.src = vec![PathBuf::from("tests/fixtures/simple_project")];
    
    let resolver = ModuleResolver::new(config);
    
    match resolver {
        Ok(resolver) => {
            let first_party_modules = resolver.get_first_party_modules();
            println!("Discovered first-party modules: {:?}", first_party_modules);
            
            // Should discover our test modules
            assert!(!first_party_modules.is_empty());
        }
        Err(e) => {
            eprintln!("Module resolution test failed: {}", e);
        }
    }
}

#[test]
fn test_dependency_graph() {
    use serpen::dependency_graph::{DependencyGraph, ModuleNode};
    use std::path::PathBuf;
    
    let mut graph = DependencyGraph::new();
    
    // Create test modules
    let main_module = ModuleNode {
        name: "main".to_string(),
        path: PathBuf::from("main.py"),
        imports: vec!["utils.helpers".to_string(), "models.user".to_string()],
    };
    
    let utils_module = ModuleNode {
        name: "utils.helpers".to_string(),
        path: PathBuf::from("utils/helpers.py"),
        imports: vec![],
    };
    
    let models_module = ModuleNode {
        name: "models.user".to_string(),
        path: PathBuf::from("models/user.py"),
        imports: vec![],
    };
    
    // Add modules to graph
    graph.add_module(main_module);
    graph.add_module(utils_module);
    graph.add_module(models_module);
    
    // Add dependencies - main depends on utils and models
    graph.add_dependency("main", "utils.helpers").unwrap();
    graph.add_dependency("main", "models.user").unwrap();
    
    // Debug: check what the graph looks like
    println!("Graph has {} modules", graph.get_modules().len());
    for module in graph.get_modules() {
        if let Some(deps) = graph.get_dependencies(&module.name) {
            println!("Module {} depends on: {:?}", module.name, deps);
        }
    }
    
    // Test topological sort
    let sorted = graph.topological_sort().unwrap();
    assert_eq!(sorted.len(), 3);
    
    println!("Sorted modules:");
    for (i, module) in sorted.iter().enumerate() {
        println!("  {}: {}", i, module.name);
    }
    
    // Dependencies should come before main module
    let main_index = sorted.iter().position(|m| m.name == "main").unwrap();
    let utils_index = sorted.iter().position(|m| m.name == "utils.helpers").unwrap();
    let models_index = sorted.iter().position(|m| m.name == "models.user").unwrap();
    
    println!("Indices: main={}, utils={}, models={}", main_index, utils_index, models_index);
    
    assert!(utils_index < main_index);
    assert!(models_index < main_index);
    
    println!("Dependency graph test passed!");
}
