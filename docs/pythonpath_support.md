# PYTHONPATH Support in Cribo

## Overview

Cribo now supports module discovery through the `PYTHONPATH` environment variable. This allows the bundler to discover and include modules from directories specified in `PYTHONPATH`, treating them as first-party modules alongside those in configured source directories.

## How It Works

1. **Module Discovery**: When Cribo initializes the `ModuleResolver`, it reads the `PYTHONPATH` environment variable and includes all valid directories in the module discovery process.

2. **Directory Scanning**: PYTHONPATH directories are scanned alongside configured `src` directories to find Python modules and packages.

3. **Module Classification**: Modules found in PYTHONPATH directories are classified as first-party modules, meaning they will be bundled into the final output.

4. **Path Resolution**: When resolving module imports, Cribo searches both configured source directories and PYTHONPATH directories.

## Usage

Set the `PYTHONPATH` environment variable before running Cribo:

```bash
export PYTHONPATH="/path/to/additional/modules:/another/path"
cribo --entry main.py --output bundle.py
```

Or inline:

```bash
PYTHONPATH="/path/to/modules" cribo --entry main.py --output bundle.py
```

## PYTHONPATH Format

The `PYTHONPATH` environment variable should contain colon-separated directory paths (on Unix-like systems):

```bash
PYTHONPATH="/path/to/dir1:/path/to/dir2:/path/to/dir3"
```

## Examples

### Basic Example

Directory structure:

```
project/
├── src/
│   └── main.py
└── external_modules/
    └── helper.py
```

Files:

```python
# external_modules/helper.py
def get_message():
    return "Hello from PYTHONPATH!"

# src/main.py
from helper import get_message

def main():
    print(get_message())

if __name__ == "__main__":
    main()
```

Bundle with PYTHONPATH:

```bash
cd project
PYTHONPATH="./external_modules" cribo --entry src/main.py --output bundle.py
```

The generated `bundle.py` will include both modules:

```python
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler

# ─ Module: helper ─
def get_message():
    return "Hello from PYTHONPATH!"

# ─ Entry Module: main ─
def main():
    print(get_message())

if __name__ == "__main__":
    main()
```

### Package Example

Directory structure:

```
project/
├── src/
│   └── main.py
└── libs/
    └── mypackage/
        ├── __init__.py
        └── utils.py
```

Files:

```python
# libs/mypackage/__init__.py
# Package initialization

# libs/mypackage/utils.py
def utility_function():
    return "Utility from PYTHONPATH package"

# src/main.py
from mypackage.utils import utility_function

def main():
    print(utility_function())

if __name__ == "__main__":
    main()
```

Bundle with PYTHONPATH:

```bash
cd project
PYTHONPATH="./libs" cribo --entry src/main.py --output bundle.py
```

## Implementation Details

### ModuleResolver Changes

The `ModuleResolver` class was enhanced with:

1. **`get_scan_directories()` method**: Combines configured `src` directories with PYTHONPATH directories
2. **Enhanced `discover_first_party_modules()`**: Scans both types of directories
3. **Updated `resolve_module_path()`**: Searches all directories when resolving module paths

### PYTHONPATH Parsing

- Directories are split by colon (`:`) on Unix-like systems
- Empty path components are ignored
- Non-existent directories are filtered out
- Only directories (not files) are included

### Directory Deduplication

Cribo automatically deduplicates directories when the same path appears in both configured `src` directories and PYTHONPATH. This prevents scanning the same directory twice and improves performance.

**Features:**

- **Path canonicalization**: All paths are resolved to their canonical (absolute) form for accurate comparison
- **Automatic deduplication**: Duplicate directories are removed using HashSet-based deduplication
- **Graceful fallback**: If canonicalization fails but the path exists, the original path is used

**Example scenario:**

```bash
# Directory structure
project/
├── src/           # Configured in cribo.toml
└── external/      # Additional modules

# If both are specified:
# - cribo.toml: src = ["src"]  
# - PYTHONPATH="./src:./external"

# Result: Only scans each directory once, even though "src" appears in both
```

### Module Classification

Modules found in PYTHONPATH directories are treated identically to modules in configured source directories:

- Classified as `ImportType::FirstParty`
- Included in bundling process
- Subject to unused import analysis

## Configuration Integration

PYTHONPATH support works alongside existing configuration:

```toml
# cribo.toml
src = ["src", "lib"]
known_first_party = ["my_custom_module"]
known_third_party = ["requests", "numpy"]
```

With this configuration and `PYTHONPATH="/extra/modules"`, Cribo will scan:

1. `src/` directory
2. `lib/` directory
3. `/extra/modules/` directory

## Testing

The implementation includes comprehensive tests:

- Unit tests for `get_scan_directories()` method
- Integration tests for module discovery
- Tests for module classification
- Tests for multiple PYTHONPATH directories
- Tests for edge cases (empty/nonexistent paths)

## Limitations

- PYTHONPATH parsing uses Unix-style colon separators (compatible with macOS and Linux)
- Windows path separator (`;`) is not currently supported
- PYTHONPATH directories must exist and be readable
- Relative paths in PYTHONPATH are resolved relative to the current working directory

## Debug Information

When running with `--verbose` flag, Cribo logs PYTHONPATH discovery:

```
[DEBUG] Scanning source directory: "/configured/src"
[DEBUG] Found first-party module: main
[DEBUG] Scanning source directory: "/path/from/pythonpath"  
[DEBUG] Found first-party module: external_module
```

This helps verify that PYTHONPATH modules are being discovered correctly.
