use std::path::PathBuf;

/// CriboGraph: Advanced dependency graph implementation for Python bundling
///
/// This module provides a sophisticated dependency tracking system that combines:
/// - Fine-grained item-level tracking (inspired by Turbopack)
/// - Incremental update support (inspired by Rspack)
/// - Efficient graph algorithms using petgraph (inspired by Mako)
///
/// Key features:
/// - Statement/item level dependency tracking for precise tree shaking
/// - Incremental updates with partial graph modifications
/// - Cycle detection and handling
/// - Variable state tracking across scopes
/// - Side effect preservation
use anyhow::{Result, anyhow};
use indexmap::IndexSet;
use log::debug;
use petgraph::{
    algo::{is_cyclic_directed, toposort},
    graph::{DiGraph, NodeIndex},
};
use rustc_hash::{FxHashMap, FxHashSet};

/// Unique identifier for a module
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct ModuleId(u32);

impl ModuleId {
    pub fn new(id: u32) -> Self {
        Self(id)
    }

    /// Returns the underlying u32 value of the ModuleId
    #[inline]
    pub const fn as_u32(&self) -> u32 {
        self.0
    }
}

/// Unique identifier for an item within a module
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct ItemId(u32);

impl ItemId {
    pub fn new(id: u32) -> Self {
        Self(id)
    }
}

/// Type of Python item (statement/definition)
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ItemType {
    /// Function definition
    FunctionDef { name: String },
    /// Class definition
    ClassDef { name: String },
    /// Variable assignment
    Assignment { targets: Vec<String> },
    /// Import statement
    Import {
        module: String,
        alias: Option<String>, // import module as alias
    },
    /// From import statement
    FromImport {
        module: String,
        names: Vec<(String, Option<String>)>, // (name, alias)
        level: u32,                           // relative import level
        is_star: bool,                        // from module import *
    },
    /// Module-level expression (side effect)
    Expression,
    /// If statement (for conditional imports)
    If { condition: String },
    /// Try-except block
    Try,
    /// Other statement types
    Other,
}

impl ItemType {
    /// Get the name of this item if it has one
    pub fn name(&self) -> Option<&str> {
        match self {
            ItemType::FunctionDef { name } => Some(name),
            ItemType::ClassDef { name } => Some(name),
            _ => None,
        }
    }
}

/// Information about a module-level dependency edge
#[derive(Debug, Clone, Default)]
pub struct ModuleDependencyInfo {}

/// Variable state tracking
#[derive(Debug, Clone)]
pub struct VarState {
    /// Items that write to this variable
    pub writers: Vec<ItemId>,
    /// Items that read this variable
    pub readers: Vec<ItemId>,
}

/// Information about an unused import
#[derive(Debug, Clone)]
pub struct UnusedImportInfo {
    /// The imported name that is unused
    pub name: String,
    /// The module it was imported from
    pub module: String,
}

/// Context for checking if an import is unused
struct ImportUsageContext<'a> {
    imported_name: &'a str,
    import_id: ItemId,
    is_init_py: bool,
    import_data: &'a ItemData,
}

/// Data about a Python item (statement/definition)
#[derive(Debug, Clone)]
pub struct ItemData {
    /// Type of this item
    pub item_type: ItemType,
    /// Variables declared by this item
    pub var_decls: FxHashSet<String>,
    /// Variables read by this item during execution
    pub read_vars: FxHashSet<String>,
    /// Variables read eventually (e.g., inside function bodies)
    pub eventual_read_vars: FxHashSet<String>,
    /// Variables written by this item
    pub write_vars: FxHashSet<String>,
    /// Variables written eventually
    pub eventual_write_vars: FxHashSet<String>,
    /// Whether this item has side effects
    pub has_side_effects: bool,
    /// For imports: the local names introduced by this import
    pub imported_names: FxHashSet<String>,
    /// For re-exports: names that are explicitly re-exported
    pub reexported_names: FxHashSet<String>,
    /// NEW: Top-level symbols defined by this item (for tree-shaking)
    pub defined_symbols: FxHashSet<String>,
    /// NEW: Map of symbol -> other symbols it references (for tree-shaking)
    pub symbol_dependencies: FxHashMap<String, FxHashSet<String>>,
    /// NEW: Map of variable -> accessed attributes (for tree-shaking namespace access)
    /// e.g., {"greetings": ["message"]} for greetings.message
    pub attribute_accesses: FxHashMap<String, FxHashSet<String>>,
    /// Track if this import was generated by stdlib normalization
    pub is_normalized_import: bool,
}

/// Fine-grained dependency graph for a single module
#[derive(Debug)]
pub struct ModuleDepGraph {
    /// Module identifier
    pub module_id: ModuleId,
    /// Module name (e.g., "utils.helpers")
    pub module_name: String,
    /// All items in this module
    pub items: FxHashMap<ItemId, ItemData>,
    /// Items that are executed for side effects (in order)
    pub side_effect_items: Vec<ItemId>,
    /// Variable state tracking
    pub var_states: FxHashMap<String, VarState>,
    /// Next item ID to allocate
    next_item_id: u32,
}

impl ModuleDepGraph {
    /// Create a new module dependency graph
    pub fn new(module_id: ModuleId, module_name: String) -> Self {
        Self {
            module_id,
            module_name,
            items: FxHashMap::default(),
            side_effect_items: Vec::new(),
            var_states: FxHashMap::default(),
            next_item_id: 0,
        }
    }

    /// Create a new module dependency graph that shares items from another graph
    /// This is used when the same file is imported with different names
    pub fn new_with_shared_items(
        module_id: ModuleId,
        module_name: String,
        source_graph: &ModuleDepGraph,
    ) -> Self {
        Self {
            module_id,
            module_name,
            // Clone all the data from the source graph to share the same items
            items: source_graph.items.clone(),
            side_effect_items: source_graph.side_effect_items.clone(),
            var_states: source_graph.var_states.clone(),
            next_item_id: source_graph.next_item_id,
        }
    }

    /// Add a new item to the graph
    pub fn add_item(&mut self, data: ItemData) -> ItemId {
        let id = ItemId::new(self.next_item_id);
        self.next_item_id += 1;

        // Track imported names as variable declarations
        for imported_name in &data.imported_names {
            self.var_states
                .entry(imported_name.clone())
                .or_insert_with(|| VarState {
                    writers: Vec::new(),
                    readers: Vec::new(),
                });
        }

        // Track variable declarations
        for var in &data.var_decls {
            self.var_states
                .entry(var.clone())
                .or_insert_with(|| VarState {
                    writers: Vec::new(),
                    readers: Vec::new(),
                });
        }

        // Track variable reads
        for var in &data.read_vars {
            if let Some(state) = self.var_states.get_mut(var) {
                state.readers.push(id);
            }
        }

        // Track variable writes
        for var in &data.write_vars {
            if let Some(state) = self.var_states.get_mut(var) {
                state.writers.push(id);
            }
        }

        // Track side effects
        if data.has_side_effects {
            self.side_effect_items.push(id);
        }

        self.items.insert(id, data);
        id
    }

    /// Find unused imports in the module
    pub fn find_unused_imports(&self, is_init_py: bool) -> Vec<UnusedImportInfo> {
        let mut unused_imports = Vec::new();

        // First, collect all imported names
        let mut imported_items: Vec<(ItemId, &ItemData)> = Vec::new();
        for (id, data) in &self.items {
            if matches!(
                data.item_type,
                ItemType::Import { .. } | ItemType::FromImport { .. }
            ) && !data.imported_names.is_empty()
            {
                imported_items.push((*id, data));
            }
        }

        // For each imported name, check if it's used
        for (import_id, import_data) in imported_items {
            for imported_name in &import_data.imported_names {
                let ctx = ImportUsageContext {
                    imported_name,
                    import_id,
                    is_init_py,
                    import_data,
                };

                if self.is_import_unused(ctx) {
                    let module_name = match &import_data.item_type {
                        ItemType::Import { module, .. } => module.clone(),
                        ItemType::FromImport { module, .. } => module.clone(),
                        _ => continue,
                    };

                    unused_imports.push(UnusedImportInfo {
                        name: imported_name.clone(),
                        module: module_name,
                    });
                }
            }
        }

        unused_imports
    }

    /// Get all import items in the module with their IDs
    pub fn get_all_import_items(&self) -> Vec<(ItemId, &ItemData)> {
        self.items
            .iter()
            .filter(|(_, data)| {
                matches!(
                    data.item_type,
                    ItemType::Import { .. } | ItemType::FromImport { .. }
                )
            })
            .map(|(id, data)| (*id, data))
            .collect()
    }

    /// Check if a name is in __all__ export
    pub fn is_in_all_export(&self, name: &str) -> bool {
        // Look for __all__ assignments
        for item_data in self.items.values() {
            if let ItemType::Assignment { targets, .. } = &item_data.item_type
                && targets.contains(&"__all__".to_string())
            {
                // Check if the name is in the eventual_read_vars (where __all__ names are
                // stored)
                if item_data.eventual_read_vars.contains(name) {
                    return true;
                }
            }
        }
        false
    }

    /// Check if a symbol uses a specific import
    pub fn does_symbol_use_import(&self, symbol: &str, import_name: &str) -> bool {
        // Find the item that defines the symbol
        for item in self.items.values() {
            if item.defined_symbols.contains(symbol) {
                // Check if this item uses the import
                if item.read_vars.contains(import_name)
                    || item.eventual_read_vars.contains(import_name)
                {
                    return true;
                }

                // Check symbol-specific dependencies
                if let Some(deps) = item.symbol_dependencies.get(symbol)
                    && deps.contains(import_name)
                {
                    return true;
                }
            }
        }
        false
    }

    /// Check if a specific imported name is unused
    fn is_import_unused(&self, ctx: ImportUsageContext<'_>) -> bool {
        // Check for special cases where imports should be preserved
        if ctx.is_init_py {
            // In __init__.py, preserve all imports as they might be part of the public API
            return false;
        }

        // Check if it's a star import
        if let ItemType::FromImport { is_star: true, .. } = &ctx.import_data.item_type {
            // Star imports are always preserved
            return false;
        }

        // Check if it's explicitly re-exported
        if ctx.import_data.reexported_names.contains(ctx.imported_name) {
            return false;
        }

        // Check if it's in __all__ (module re-export)
        if self.is_in_all_export(ctx.imported_name) {
            return false;
        }

        // Check if the import has side effects (includes stdlib imports)
        if ctx.import_data.has_side_effects {
            return false;
        }

        // Check if the name is used anywhere in the module
        for (item_id, item_data) in &self.items {
            // Skip the import statement itself
            if *item_id == ctx.import_id {
                continue;
            }

            // Check if the name is read by this item
            if item_data.read_vars.contains(ctx.imported_name)
                || item_data.eventual_read_vars.contains(ctx.imported_name)
            {
                log::trace!(
                    "Import '{}' is used by item {:?} (read_vars: {:?}, eventual_read_vars: {:?})",
                    ctx.imported_name,
                    item_id,
                    item_data.read_vars,
                    item_data.eventual_read_vars
                );
                return false;
            }

            // For dotted imports like `import xml.etree.ElementTree`, also check if any of the
            // declared variables from that import are used
            if let Some(import_item) = self.items.get(&ctx.import_id) {
                let is_var_used = import_item.var_decls.iter().any(|var_decl| {
                    item_data.read_vars.contains(var_decl)
                        || item_data.eventual_read_vars.contains(var_decl)
                });

                if is_var_used {
                    log::trace!(
                        "Import '{}' is used via declared variables by item {:?}",
                        ctx.imported_name,
                        item_id
                    );
                    return false;
                }
            }
        }

        // Check if the name is in the module's __all__ export list
        if self.is_in_module_exports(ctx.imported_name) {
            return false;
        }

        log::trace!("Import '{}' is UNUSED", ctx.imported_name);
        true
    }

    /// Check if a name is in the module's __all__ export list
    fn is_in_module_exports(&self, name: &str) -> bool {
        // Look for __all__ assignment
        for item_data in self.items.values() {
            if let ItemType::Assignment { targets } = &item_data.item_type
                && targets.contains(&"__all__".to_string())
            {
                // Check if the name is in the reexported_names set
                // which contains the parsed __all__ list values
                return item_data.reexported_names.contains(name);
            }
        }
        false
    }
}


/// State for Tarjan's strongly connected components algorithm
struct TarjanState {
    index_counter: usize,
    stack: Vec<NodeIndex>,
    indices: FxHashMap<NodeIndex, usize>,
    lowlinks: FxHashMap<NodeIndex, usize>,
    on_stack: FxHashMap<NodeIndex, bool>,
    components: Vec<Vec<NodeIndex>>,
}


/// Analysis result for cycle modules
struct CycleAnalysisResult {
    has_only_constants: bool,
    has_class_definitions: bool,
    has_module_level_imports: bool,
    imports_used_in_functions_only: bool,
}

/// Comprehensive analysis of circular dependencies
#[derive(Debug, Clone)]
pub struct CircularDependencyAnalysis {
    /// Circular dependencies that can be resolved through code transformations
    pub resolvable_cycles: Vec<CircularDependencyGroup>,
    /// Circular dependencies that cannot be resolved
    pub unresolvable_cycles: Vec<CircularDependencyGroup>,
}

/// A group of modules forming a circular dependency
#[derive(Debug, Clone)]
pub struct CircularDependencyGroup {
    pub modules: Vec<String>,
    pub cycle_type: CircularDependencyType,
    pub suggested_resolution: ResolutionStrategy,
}

/// Type of circular dependency
#[derive(Debug, Clone, PartialEq)]
pub enum CircularDependencyType {
    /// Can be resolved by moving imports inside functions
    FunctionLevel,
    /// May be resolvable depending on usage patterns
    ClassLevel,
    /// Unresolvable - temporal paradox
    ModuleConstants,
    /// Depends on execution order
    ImportTime,
}

/// Resolution strategy for circular dependencies
#[derive(Debug, Clone)]
pub enum ResolutionStrategy {
    LazyImport,
    FunctionScopedImport,
    ModuleSplit,
    Unresolvable { reason: String },
}


/// High-level dependency graph managing multiple modules
/// Combines the best of three approaches:
/// - Turbopack's fine-grained tracking
/// - Rspack's incremental updates
/// - Mako's petgraph efficiency
#[derive(Debug)]
pub struct CriboGraph {
    /// All modules in the graph
    pub modules: FxHashMap<ModuleId, ModuleDepGraph>,
    /// Module name to ID mapping
    pub module_names: FxHashMap<String, ModuleId>,
    /// Module path to ID mapping
    pub module_paths: FxHashMap<PathBuf, ModuleId>,
    /// Petgraph for efficient algorithms (inspired by Mako)
    graph: DiGraph<ModuleId, ModuleDependencyInfo>,
    /// Node index mapping
    node_indices: FxHashMap<ModuleId, NodeIndex>,
    /// Next module ID to allocate
    next_module_id: u32,

    // NEW: Fields for file-based deduplication
    /// Track canonical paths for each module
    module_canonical_paths: FxHashMap<ModuleId, PathBuf>,
    /// Track all import names that resolve to each canonical file
    /// This includes regular imports AND static importlib calls
    file_to_import_names: FxHashMap<PathBuf, IndexSet<String>>,
    /// Track the primary module ID for each file
    /// (The first import name discovered for this file)
    file_primary_module: FxHashMap<PathBuf, (String, ModuleId)>,
}

impl CriboGraph {

    /// Create a new cribo dependency graph
    pub fn new() -> Self {
        Self {
            modules: FxHashMap::default(),
            module_names: FxHashMap::default(),
            module_paths: FxHashMap::default(),
            graph: DiGraph::new(),
            node_indices: FxHashMap::default(),
            next_module_id: 0,
            module_canonical_paths: FxHashMap::default(),
            file_to_import_names: FxHashMap::default(),
            file_primary_module: FxHashMap::default(),
        }
    }

    /// Add a new module to the graph
    pub fn add_module(&mut self, name: String, path: PathBuf) -> ModuleId {
        // Always work with canonical paths
        let canonical_path = path.canonicalize().unwrap_or_else(|_| path.clone());

        // Check if this exact import name already exists
        if let Some(&existing_id) = self.module_names.get(&name) {
            // Verify it's the same file
            if let Some(existing_canonical) = self.module_canonical_paths.get(&existing_id) {
                if existing_canonical == &canonical_path {
                    return existing_id; // Same import name, same file - reuse
                } else {
                    // Error: same import name but different files
                    // This shouldn't happen with proper PYTHONPATH management
                    log::error!(
                        "Import name '{name}' refers to different files: {existing_canonical:?} \
                         and {canonical_path:?}. This may indicate a PYTHONPATH configuration \
                         issue or naming conflict. Consider using unique module names or \
                         adjusting your Python path configuration."
                    );
                }
            }
        }

        // Track this import name for the file
        self.file_to_import_names
            .entry(canonical_path.clone())
            .or_default()
            .insert(name.clone());

        // Check if this file already has a primary module
        if let Some((primary_name, primary_id)) = self.file_primary_module.get(&canonical_path) {
            log::info!(
                "File {canonical_path:?} already imported as '{primary_name}', adding additional \
                 import name '{name}'"
            );

            // Create a new ModuleId that shares the same dependency graph
            // This allows different import names to have different dependency relationships
            // while still pointing to the same file
            let id = ModuleId::new(self.next_module_id);
            self.next_module_id += 1;

            // Clone the dependency graph structure but with new module name
            let primary_graph = &self.modules[primary_id];
            let module = ModuleDepGraph::new_with_shared_items(id, name.clone(), primary_graph);

            // Now the new module shares the same item registry as the primary module
            self.modules.insert(id, module);
            self.module_names.insert(name, id);
            self.module_canonical_paths.insert(id, canonical_path);

            // Add to petgraph
            let node_idx = self.graph.add_node(id);
            self.node_indices.insert(id, node_idx);


            return id;
        }

        // This is the first time we're seeing this file
        let id = ModuleId::new(self.next_module_id);
        self.next_module_id += 1;

        // Create module
        let module_graph = ModuleDepGraph::new(id, name.clone());
        self.modules.insert(id, module_graph);
        self.module_names.insert(name.clone(), id);
        self.module_paths.insert(canonical_path.clone(), id);
        self.module_canonical_paths
            .insert(id, canonical_path.clone());
        self.file_primary_module
            .insert(canonical_path.clone(), (name.clone(), id));

        // Add to petgraph
        let node_idx = self.graph.add_node(id);
        self.node_indices.insert(id, node_idx);

        // Check if module is from stdlib
        let root_module = name.split('.').next().unwrap_or(&name);
        let _is_stdlib = ruff_python_stdlib::sys::is_known_standard_library(10, root_module);


        log::debug!("Registered module '{name}' as primary for file {canonical_path:?}");

        id
    }

    /// Get a module by name
    pub fn get_module_by_name(&self, name: &str) -> Option<&ModuleDepGraph> {
        self.module_names
            .get(name)
            .and_then(|&id| self.modules.get(&id))
    }

    /// Get a mutable module by name
    pub fn get_module_by_name_mut(&mut self, name: &str) -> Option<&mut ModuleDepGraph> {
        if let Some(&id) = self.module_names.get(name) {
            self.modules.get_mut(&id)
        } else {
            None
        }
    }

    /// Add a dependency between modules (from depends on to)
    pub fn add_module_dependency(&mut self, from: ModuleId, to: ModuleId) {
        self.add_module_dependency_with_info(from, to, ModuleDependencyInfo::default());
    }

    /// Add a dependency between modules with additional information
    pub fn add_module_dependency_with_info(
        &mut self,
        from: ModuleId,
        to: ModuleId,
        info: ModuleDependencyInfo,
    ) {
        if let (Some(&from_idx), Some(&to_idx)) =
            (self.node_indices.get(&from), self.node_indices.get(&to))
        {
            // For topological sort to work correctly with petgraph,
            // we need edge from dependency TO dependent
            // So if A depends on B, we add edge B -> A

            // Check if edge already exists to avoid duplicates
            if !self.graph.contains_edge(to_idx, from_idx) {
                self.graph.add_edge(to_idx, from_idx, info);
            }
        }
    }

    /// Get topologically sorted modules (uses petgraph)
    pub fn topological_sort(&self) -> Result<Vec<ModuleId>> {
        toposort(&self.graph, None)
            .map(|nodes| nodes.into_iter().map(|n| self.graph[n]).collect())
            .map_err(|_| anyhow!("Circular dependency detected"))
    }

    /// Check if the graph has cycles
    pub fn has_cycles(&self) -> bool {
        is_cyclic_directed(&self.graph)
    }

    /// Get all modules that a given module depends on
    pub fn get_dependencies(&self, module_id: ModuleId) -> Vec<ModuleId> {
        if let Some(&node_idx) = self.node_indices.get(&module_id) {
            // Since edges go from dependency to dependent, incoming edges are dependencies
            self.graph
                .neighbors_directed(node_idx, petgraph::Direction::Incoming)
                .map(|idx| self.graph[idx])
                .collect()
        } else {
            vec![]
        }
    }

    /// Find all strongly connected components (circular dependencies) using Tarjan's algorithm
    /// This is more efficient than Kosaraju for our use case and provides components in
    /// reverse topological order
    pub fn find_strongly_connected_components(&self) -> Vec<Vec<ModuleId>> {
        let mut state = TarjanState {
            index_counter: 0,
            stack: Vec::new(),
            indices: FxHashMap::default(),
            lowlinks: FxHashMap::default(),
            on_stack: FxHashMap::default(),
            components: Vec::new(),
        };

        for node_index in self.graph.node_indices() {
            if !state.indices.contains_key(&node_index) {
                self.tarjan_strongconnect(node_index, &mut state);
            }
        }

        // Convert NodeIndex components to ModuleId components
        state
            .components
            .into_iter()
            .map(|component| component.into_iter().map(|idx| self.graph[idx]).collect())
            .collect()
    }

    /// Helper for Tarjan's algorithm
    fn tarjan_strongconnect(&self, v: NodeIndex, state: &mut TarjanState) {
        state.indices.insert(v, state.index_counter);
        state.lowlinks.insert(v, state.index_counter);
        state.index_counter += 1;
        state.stack.push(v);
        state.on_stack.insert(v, true);

        // Note: Our edges go from dependency to dependent, so we traverse outgoing edges
        for w in self
            .graph
            .neighbors_directed(v, petgraph::Direction::Outgoing)
        {
            if !state.indices.contains_key(&w) {
                self.tarjan_strongconnect(w, state);
                let w_lowlink = *state.lowlinks.get(&w).expect("w should exist in lowlinks");
                let v_lowlink = *state.lowlinks.get(&v).expect("v should exist in lowlinks");
                state.lowlinks.insert(v, v_lowlink.min(w_lowlink));
            } else if *state.on_stack.get(&w).unwrap_or(&false) {
                let w_index = *state.indices.get(&w).expect("w should exist in indices");
                let v_lowlink = *state.lowlinks.get(&v).expect("v should exist in lowlinks");
                state.lowlinks.insert(v, v_lowlink.min(w_index));
            }
        }

        if state.lowlinks[&v] == state.indices[&v] {
            let component = self.pop_scc_component(&mut state.stack, &mut state.on_stack, v);
            if component.len() > 1 {
                state.components.push(component);
            }
        }
    }

    /// Pop a strongly connected component from the stack
    fn pop_scc_component(
        &self,
        stack: &mut Vec<NodeIndex>,
        on_stack: &mut FxHashMap<NodeIndex, bool>,
        v: NodeIndex,
    ) -> Vec<NodeIndex> {
        let mut component = Vec::new();
        while let Some(w) = stack.pop() {
            on_stack.insert(w, false);
            component.push(w);
            if w == v {
                break;
            }
        }
        component
    }

    /// Find all strongly connected components (circular dependencies) - alias for compatibility
    pub fn find_cycles(&self) -> Vec<Vec<ModuleId>> {
        self.find_strongly_connected_components()
    }


    /// Find cycle paths using DFS with three-color marking

    /// Analyze circular dependencies and classify them
    pub fn analyze_circular_dependencies(&self) -> CircularDependencyAnalysis {
        let sccs = self.find_strongly_connected_components();

        let mut resolvable_cycles = Vec::new();
        let mut unresolvable_cycles = Vec::new();

        for scc in &sccs {
            // Skip single-node SCCs (self-cycles)
            if scc.len() <= 1 {
                continue;
            }

            let module_names: Vec<String> = scc
                .iter()
                .filter_map(|&module_id| {
                    self.modules
                        .get(&module_id)
                        .map(|module| module.module_name.clone())
                })
                .collect();

            // Classify the cycle type
            let cycle_type = self.classify_cycle_type(&module_names);

            // Suggest resolution strategy
            let suggested_resolution =
                self.suggest_resolution_for_cycle(&cycle_type, &module_names);

            let group = CircularDependencyGroup {
                modules: module_names,
                cycle_type: cycle_type.clone(),
                suggested_resolution,
            };

            // Categorize based on cycle type
            match cycle_type {
                CircularDependencyType::ModuleConstants => {
                    unresolvable_cycles.push(group);
                }
                _ => {
                    resolvable_cycles.push(group);
                }
            }
        }

        CircularDependencyAnalysis {
            resolvable_cycles,
            unresolvable_cycles,
        }
    }

    /// Classify the type of circular dependency
    fn classify_cycle_type(&self, module_names: &[String]) -> CircularDependencyType {
        // Check if this is a parent-child package cycle
        // These occur when a package imports from its subpackage (e.g., pkg/__init__.py imports
        // from pkg.submodule)
        if self.is_parent_child_package_cycle(module_names) {
            // This is a normal Python pattern, not a problematic cycle
            return CircularDependencyType::FunctionLevel; // Most permissive type
        }

        // Perform AST analysis on the modules in the cycle
        let analysis_result = self.analyze_cycle_modules(module_names);

        // Use AST analysis results for classification
        if analysis_result.has_only_constants
            && !module_names.iter().any(|name| name.ends_with("__init__"))
        {
            // Modules that only contain constants create unresolvable cycles
            // Exception: __init__.py files often only have imports/exports which is normal
            return CircularDependencyType::ModuleConstants;
        }

        if analysis_result.has_class_definitions {
            // Check if the circular imports are used for inheritance
            // If all imports in the cycle are only used in functions, it's still FunctionLevel
            if analysis_result.imports_used_in_functions_only {
                return CircularDependencyType::FunctionLevel;
            }
            // Otherwise, it's a true class-level cycle
            return CircularDependencyType::ClassLevel;
        }

        // Fall back to name-based heuristics if AST analysis is inconclusive
        for module_name in module_names {
            if module_name.contains("constants") || module_name.contains("config") {
                return CircularDependencyType::ModuleConstants;
            }
            if module_name.contains("class") || module_name.ends_with("_class") {
                return CircularDependencyType::ClassLevel;
            }
        }

        // Check if imports can be moved to functions
        // Special case: if modules have NO items (empty or only imports), treat as FunctionLevel
        // This handles simple circular import cases like stickytape tests
        if self.all_modules_empty_or_imports_only(module_names) {
            // Simple circular imports can often be resolved
            CircularDependencyType::FunctionLevel
        } else if analysis_result.imports_used_in_functions_only {
            CircularDependencyType::FunctionLevel
        } else if analysis_result.has_module_level_imports
            || module_names.iter().any(|name| name.contains("__init__"))
        {
            CircularDependencyType::ImportTime
        } else {
            CircularDependencyType::FunctionLevel
        }
    }

    /// Analyze modules in a cycle to determine their characteristics
    fn analyze_cycle_modules(&self, module_names: &[String]) -> CycleAnalysisResult {
        let mut has_only_constants = true;
        let mut has_class_definitions = false;
        let mut has_module_level_imports = false;
        let mut imports_used_in_functions_only = true;

        for module_name in module_names {
            let Some(&module_id) = self.module_names.get(module_name) else {
                continue;
            };

            let Some(module) = self.modules.get(&module_id) else {
                continue;
            };

            // Check if module only contains constant assignments
            let module_has_only_constants = self.module_has_only_constants(module);
            has_only_constants = has_only_constants && module_has_only_constants;

            // Check for class definitions
            if self.module_has_class_definitions(module) {
                has_class_definitions = true;
            }

            // Check if imports are at module level
            if self.module_has_module_level_imports(module) {
                has_module_level_imports = true;

                // Now check if those imports are only used inside functions
                if !self.are_imports_used_only_in_functions(module) {
                    imports_used_in_functions_only = false;
                }
            }
        }

        CycleAnalysisResult {
            has_only_constants,
            has_class_definitions,
            has_module_level_imports,
            imports_used_in_functions_only: !has_module_level_imports
                || imports_used_in_functions_only,
        }
    }

    /// Check if a module only contains constant assignments
    fn module_has_only_constants(&self, module: &ModuleDepGraph) -> bool {
        // Empty modules (no items) should not be considered as "only constants"
        // Modules with only imports should not be considered as "only constants"
        !module.items.is_empty()
            && module
                .items
                .values()
                .any(|item| matches!(item.item_type, ItemType::Assignment { .. }))
            && !module.items.values().any(|item| {
                matches!(
                    &item.item_type,
                    ItemType::FunctionDef { .. }
                        | ItemType::ClassDef { .. }
                        | ItemType::Expression
                        | ItemType::If { .. }
                        | ItemType::Try
                )
            })
    }

    /// Check if a module has class definitions
    fn module_has_class_definitions(&self, module: &ModuleDepGraph) -> bool {
        module
            .items
            .values()
            .any(|item| matches!(item.item_type, ItemType::ClassDef { .. }))
    }

    /// Check if a module has module-level imports
    fn module_has_module_level_imports(&self, module: &ModuleDepGraph) -> bool {
        module.items.values().any(|item| {
            matches!(
                item.item_type,
                ItemType::Import { .. } | ItemType::FromImport { .. }
            )
        })
    }

    /// Check if all modules in the cycle are empty or only contain imports
    fn all_modules_empty_or_imports_only(&self, module_names: &[String]) -> bool {
        module_names.iter().all(|module_name| {
            let Some(&module_id) = self.module_names.get(module_name) else {
                return true; // Module not found, assume empty
            };

            let Some(module) = self.modules.get(&module_id) else {
                return true; // Module not found, assume empty
            };

            // Module has no items, or only has import items
            module.items.is_empty()
                || module.items.values().all(|item| {
                    matches!(
                        item.item_type,
                        ItemType::Import { .. } | ItemType::FromImport { .. }
                    )
                })
        })
    }

    /// Check if imported items are only used inside functions
    fn are_imports_used_only_in_functions(&self, module: &ModuleDepGraph) -> bool {
        // Get all imported names from this module
        let mut imported_names = FxHashSet::default();

        // TODO: This has O(n*m) complexity where n is imported names and m is module items.
        // For modules with many imports and items, consider building an index of variable
        // usage upfront to reduce lookup time.

        for item in module.items.values() {
            match &item.item_type {
                ItemType::Import { alias, module } => {
                    let local_name = alias.as_ref().unwrap_or(module).clone();
                    imported_names.insert(local_name.clone());

                    // For dotted imports like `import xml.etree.ElementTree`,
                    // also track the root module name (e.g., "xml")
                    // since that's what appears in read_vars
                    if alias.is_none()
                        && module.contains('.')
                        && let Some(root) = module.split('.').next()
                    {
                        imported_names.insert(root.to_string());
                    }
                }
                ItemType::FromImport { names, .. } => {
                    for (name, alias) in names {
                        imported_names.insert(alias.as_ref().unwrap_or(name).clone());
                    }
                }
                _ => {}
            }
        }

        debug!(
            "Module {} has imported names: {:?}",
            module.module_name, imported_names
        );

        // For each imported name, check if it's only used inside functions
        // We need to check if the import appears in any item's read_vars (module level)
        // vs only appearing in eventual_read_vars (function level)
        for imported_name in &imported_names {
            debug!(
                "Checking usage of imported '{}' in module {}",
                imported_name, module.module_name
            );

            // Check all items in the module
            for (item_id, item_data) in &module.items {
                // Skip import statements themselves
                if matches!(
                    item_data.item_type,
                    ItemType::Import { .. } | ItemType::FromImport { .. }
                ) {
                    continue;
                }

                // If the import is used in read_vars, it's used at module level
                if item_data.read_vars.contains(imported_name) {
                    debug!(
                        "  -> Import '{}' used at module level in item {:?} (type: {:?})",
                        imported_name, item_id, item_data.item_type
                    );
                    return false;
                }

                // Note: Usage in eventual_read_vars is OK - that's function-level usage
                if item_data.eventual_read_vars.contains(imported_name) {
                    debug!(
                        "  -> Import '{imported_name}' used inside function in item {item_id:?}"
                    );
                }
            }
        }

        debug!(
            "All imports in module {} are only used inside functions",
            module.module_name
        );
        true
    }

    /// Check if a cycle is a parent-child package relationship
    fn is_parent_child_package_cycle(&self, module_names: &[String]) -> bool {
        // A parent-child cycle occurs when:
        // 1. We have exactly 2 modules in the cycle
        // 2. One module is a parent package of the other
        if module_names.len() != 2 {
            return false;
        }

        let mod1 = &module_names[0];
        let mod2 = &module_names[1];

        // Check if mod1 is parent of mod2 or vice versa
        mod2.starts_with(&format!("{mod1}.")) || mod1.starts_with(&format!("{mod2}."))
    }

    /// Suggest resolution strategy for a circular dependency
    fn suggest_resolution_for_cycle(
        &self,
        cycle_type: &CircularDependencyType,
        _module_names: &[String],
    ) -> ResolutionStrategy {
        match cycle_type {
            CircularDependencyType::FunctionLevel => ResolutionStrategy::FunctionScopedImport,
            CircularDependencyType::ClassLevel => ResolutionStrategy::LazyImport,
            CircularDependencyType::ModuleConstants => ResolutionStrategy::Unresolvable {
                reason: "Module-level constants create temporal paradox - consider moving to a \
                         shared configuration module"
                    .into(),
            },
            CircularDependencyType::ImportTime => ResolutionStrategy::ModuleSplit,
        }
    }

    /// Get all import names that resolve to the same file as the given module
    pub fn get_file_import_names(&self, module_id: ModuleId) -> Vec<String> {
        if let Some(canonical_path) = self.module_canonical_paths.get(&module_id)
            && let Some(names) = self.file_to_import_names.get(canonical_path)
        {
            return names.iter().cloned().collect();
        }
        vec![]
    }

    /// Check if two modules refer to the same file
    pub fn same_file(&self, module_id1: ModuleId, module_id2: ModuleId) -> bool {
        if let (Some(path1), Some(path2)) = (
            self.module_canonical_paths.get(&module_id1),
            self.module_canonical_paths.get(&module_id2),
        ) {
            return path1 == path2;
        }
        false
    }

    /// Get the canonical path for a module
    pub fn get_canonical_path(&self, module_id: ModuleId) -> Option<&PathBuf> {
        self.module_canonical_paths.get(&module_id)
    }
}

// HashSet import moved to top

impl Default for CriboGraph {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_module_graph() {
        let mut graph = CriboGraph::new();

        let utils_id = graph.add_module("utils".to_string(), PathBuf::from("utils.py"));
        let main_id = graph.add_module("main".to_string(), PathBuf::from("main.py"));

        graph.add_module_dependency(main_id, utils_id);

        let sorted = graph
            .topological_sort()
            .expect("Topological sort should succeed for acyclic graph");
        // Since main depends on utils, utils should come first in topological order
        assert_eq!(sorted, vec![utils_id, main_id]);
    }

    #[test]
    fn test_circular_dependency_detection() {
        let mut graph = CriboGraph::new();

        // Create a three-module circular dependency: A -> B -> C -> A
        let module_a = graph.add_module("module_a".to_string(), PathBuf::from("module_a.py"));
        let module_b = graph.add_module("module_b".to_string(), PathBuf::from("module_b.py"));
        let module_c = graph.add_module("module_c".to_string(), PathBuf::from("module_c.py"));

        graph.add_module_dependency(module_a, module_b);
        graph.add_module_dependency(module_b, module_c);
        graph.add_module_dependency(module_c, module_a);

        // Check that cycles are detected
        assert!(graph.has_cycles());

        // Find strongly connected components
        let sccs = graph.find_strongly_connected_components();
        assert_eq!(sccs.len(), 1);
        assert_eq!(sccs[0].len(), 3);

        // Analyze circular dependencies
        let analysis = graph.analyze_circular_dependencies();
        assert!(!analysis.resolvable_cycles.is_empty());
    }

    #[test]
    fn test_circular_dependency_classification() {
        let mut graph = CriboGraph::new();

        // Create a circular dependency with "constants" in the name
        let constants_a =
            graph.add_module("constants_a".to_string(), PathBuf::from("constants_a.py"));
        let constants_b =
            graph.add_module("constants_b".to_string(), PathBuf::from("constants_b.py"));

        graph.add_module_dependency(constants_a, constants_b);
        graph.add_module_dependency(constants_b, constants_a);

        let analysis = graph.analyze_circular_dependencies();
        assert_eq!(analysis.unresolvable_cycles.len(), 1);
        assert_eq!(
            analysis.unresolvable_cycles[0].cycle_type,
            CircularDependencyType::ModuleConstants
        );

        // Check resolution strategy
        if let ResolutionStrategy::Unresolvable { reason } =
            &analysis.unresolvable_cycles[0].suggested_resolution
        {
            assert!(reason.contains("temporal paradox"));
        } else {
            panic!("Expected unresolvable strategy for constants cycle");
        }
    }

    #[test]
    fn test_cloned_items_for_same_file() {
        let mut graph = CriboGraph::new();

        // Add a module with a canonical path
        let path = PathBuf::from("src/utils.py");
        let utils_id = graph.add_module("utils".to_string(), path.clone());

        // Add some items to the utils module
        let utils_module = graph
            .modules
            .get_mut(&utils_id)
            .expect("Module should exist after add_module");
        let item1 = utils_module.add_item(ItemData {
            item_type: ItemType::FunctionDef {
                name: "helper".into(),
            },
            var_decls: ["helper".into()].into_iter().collect(),
            read_vars: FxHashSet::default(),
            eventual_read_vars: FxHashSet::default(),
            write_vars: FxHashSet::default(),
            eventual_write_vars: FxHashSet::default(),
            has_side_effects: false,
            imported_names: FxHashSet::default(),
            reexported_names: FxHashSet::default(),
            defined_symbols: ["helper".into()].into_iter().collect(),
            symbol_dependencies: FxHashMap::default(),
            attribute_accesses: FxHashMap::default(),
            is_normalized_import: false,
        });

        // Add the same file with a different import name
        let alt_utils_id = graph.add_module("src.utils".to_string(), path);

        // Verify that both modules exist
        assert!(graph.modules.contains_key(&utils_id));
        assert!(graph.modules.contains_key(&alt_utils_id));

        // Verify that they share the same items
        let utils_module = &graph.modules[&utils_id];
        let alt_utils_module = &graph.modules[&alt_utils_id];

        // Check that the item exists in both modules
        assert!(utils_module.items.contains_key(&item1));
        assert!(alt_utils_module.items.contains_key(&item1));

        // Check that they have the same number of items
        assert_eq!(utils_module.items.len(), alt_utils_module.items.len());

        // Check that the item data is identical
        assert_eq!(
            utils_module.items[&item1].item_type,
            alt_utils_module.items[&item1].item_type
        );

        // Verify module names are different
        assert_eq!(utils_module.module_name, "utils");
        assert_eq!(alt_utils_module.module_name, "src.utils");

        // Verify module IDs are different
        assert_ne!(utils_module.module_id, alt_utils_module.module_id);

        // Test that adding items to one module affects the other
        let item2 = {
            let utils_module = graph
                .modules
                .get_mut(&utils_id)
                .expect("Module should exist after add_module");
            utils_module.add_item(ItemData {
                item_type: ItemType::FunctionDef {
                    name: "new_helper".into(),
                },
                var_decls: ["new_helper".into()].into_iter().collect(),
                read_vars: FxHashSet::default(),
                eventual_read_vars: FxHashSet::default(),
                write_vars: FxHashSet::default(),
                eventual_write_vars: FxHashSet::default(),
                has_side_effects: false,
                imported_names: FxHashSet::default(),
                reexported_names: FxHashSet::default(),
                defined_symbols: ["new_helper".into()].into_iter().collect(),
                symbol_dependencies: FxHashMap::default(),
                attribute_accesses: FxHashMap::default(),
                is_normalized_import: false,
            })
        };

        // NOTE: The current implementation uses cloning instead of true sharing.
        // When multiple modules point to the same file, they get a snapshot of items
        // at creation time. This is the intended behavior for the bundler, as modules
        // are processed independently and items are discovered during the initial parse.
        // True sharing (e.g., Arc<RwLock<>>) would add unnecessary complexity for no
        // practical benefit in the bundling use case.
        let alt_utils_module = &graph.modules[&alt_utils_id];

        // Verify that items are NOT shared (current and intended behavior)
        assert!(
            !alt_utils_module.items.contains_key(&item2),
            "With current implementation, new items added to one module should NOT appear in \
             other modules"
        );
    }
}
