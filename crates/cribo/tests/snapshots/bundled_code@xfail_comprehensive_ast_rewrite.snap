---
source: crates/cribo/tests/test_bundling_snapshots.rs
input_file: crates/cribo/tests/fixtures/bundling/xfail_comprehensive_ast_rewrite/main.py
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

from typing import Any, Dict, List, Optional
import sys
import types
"""\nUser model with extensive naming conflicts across the project\n"""
result_1 = {"model": "user"}
connection_1 = None
class Logger_1:
    """Model Logger class - conflicts with other Logger classes"""

    def __init__(self, context: str):
        self.context = context
        self.entries = []
        self.process = self._log_process

    def _log_process(self, message: str) -> None:
        self.entries.append(f"{self.context}: {message}")

    def get_message(self) -> str:
        return f"Model Logger: {self.context}"

    def validate(self, entry: str) -> bool:
        """Method with name that conflicts with global functions"""
        return len(entry) > 0
class User_1:
    """Model User class - major conflict with other User classes"""

    def __init__(self, name: str, email: str=""):
        self.name = name
        self.email = email
        self.active = True
        self.Logger = Logger_1(f"user_{name}")
        self.process = self._user_process
        self.validate = self._user_validate
        self.result = None

    def _user_process(self, data: Any) -> str:
        """Private method using conflicted names"""
        util_result = util_process(data)
        self.Logger.validate(str(data))
        self.Logger._log_process(f"Processing: {data}")
        self.result = f"user_model_process: {util_result}"
        return self.result

    def _user_validate(self, field: str, value: Any) -> bool:
        """Private validation with name conflicts"""
        if field == "name":
            return isinstance(value, str) and len(value) > 0
        elif field == "email":
            return "@" in str(value) if value else True
        return False

    def authenticate(self, password: str) -> Dict[str, Any]:
        """Method with complex internal conflicts"""
        validate = self.validate
        process = self.process
        Logger_1 = self.Logger
        result_1 = {}
        name_valid = validate("name", self.name)
        email_valid = validate("email", self.email)
        password_valid = len(password) >= 4
        auth_data = {"name": self.name, "email": self.email, "password_length": len(password)}
        process_result = process(auth_data)
        Logger_1.validate(f"auth_{self.name}")
        result_1 = {"user": self.name, "valid": name_valid and email_valid and password_valid, "process_result": process_result, "logger_context": Logger_1.context}
        return result_1

    def connect(self) -> str:
        """Method with name that conflicts with global functions"""
        global connection
        connection_1 = f"user_model_connection_{self.name}"
        return connection_1
def process_user(data: Any) -> str:
    """Module function with naming conflicts"""
    global result
    Logger_1 = globals()["Logger"]
    validate = lambda x: x is not None
    logger = Logger_1("process_user")
    is_valid = validate(data)
    if is_valid:
        logger._log_process(f"Processing user data: {data}")
        processed = f"model_user_processed: {data}"
    else:
        processed = "model_user_invalid_data"
    result_1["last_process"] = processed
    return processed
def validate_1(user_data: Dict[str, Any]) -> bool:
    """Module validate function - conflicts with other validates"""
    required_fields = ["name"]
    return all(field in user_data for field in required_fields)
def process_1(data: Any) -> str:
    """Module process function - major conflict"""
    if isinstance(data, dict):
        return process_user(data)
    else:
        return f"model_process_generic: {data}"
class Connection_1:
    """Model connection class - conflicts with other Connection classes"""

    def __init__(self, User: "User"):
        self.User = User_1
        self.connected = False

    def connect(self) -> str:
        self.connected = True
        return f"Model connection for user: {self.User.name}"

    def process(self, action: str) -> str:
        """Method with conflicted name"""
        return f"connection_process: {action} for {self.User.name}"
def connect(User: "User") -> Connection_1:
    """Module connect function with parameter conflicts"""
    return Connection_1(User_1)
def complex_operation(User: Any=None, Logger: Any=None, process: Any=None, validate: Any=None, result: Any=None, connection: Any=None) -> Dict[str, Any]:
    """Function with all parameter names conflicting with globals/classes"""
    operation_result = {"user_param": User_1, "logger_param": Logger_1, "process_param": process_1, "validate_param": validate_1, "result_param": result_1, "connection_param": connection_1}
    User_1 = globals()["User"]
    Logger_1 = globals()["Logger"]
    if operation_result["user_param"]:
        user = User_1("complex_user")
        logger = Logger_1("complex_operation")
        operation_result["created_user"] = user.name
        operation_result["created_logger"] = logger.context
    return operation_result
process_2 = process_1
validate_2 = validate_1
User_2 = User_1
Logger_2 = Logger_1
"""\nDatabase connection module with naming conflicts\n"""
result_2 = []
connection_2 = None
class Connection_2:
    """Database connection class"""

    def __init__(self, host="localhost", port=5432):
        self.host = host
        self.port = port
        self.connected = False
        self.result = None
        self.process = self._internal_process

    def _internal_process(self, query):
        return f"db_internal: {query}"

    def connect(self):
        global connection
        self.connected = True
        connection_2 = self
        return f"Connected to {self.host}:{self.port}"
def process_3(data):
    """Database process function - conflicts with other process functions"""
    global result
    validated = helper_validate(data)
    user_result = process_user(data)
    processed = {"db_process": True, "data": validated, "user_processing": user_result, "timestamp": "2024-01-01"}
    result_2.append(processed)
    return f"db_processed: {data}"
def validate_3(data):
    """Database validate function - another conflict"""
    if not data:
        return False
    return f"db_valid: {data}"
def connect_1():
    """Module-level connect function"""
    global connection
    if connection_2 is None:
        connection_2 = Connection_2()
    return connection_2.connect()
process_4 = process_3
User_3 = "database_user_type"
"""\nUtility helpers module with extensive naming conflicts\n"""
result_3 = 0
User_4 = "helper_user_string"
class Logger_3:
    """Utility logger class - conflicts with other Logger classes"""

    def __init__(self, name: str):
        self.name = name
        self.messages: List[str] = []
        self.User = User_4

    def log(self, message: str) -> None:
        self.messages.append(f"[{self.name}] {message}")

    def get_message(self) -> str:
        return f"Utils Logger: {self.name}"

    def process(self, data: Any) -> str:
        """Method with same name as module functions"""
        return f"logger_process: {data}"
def process_5(data: Any) -> str:
    """Utility process function - major conflict with other process functions"""
    global result
    if isinstance(data, str):
        processed = data.upper()
    elif isinstance(data, (int, float)):
        processed = data * 2
    elif isinstance(data, dict):
        processed = {k: f"util_{v}" for k, v in data.items()}
    else:
        processed = str(data)
    result_3 += 1
    return f"util_processed: {processed}"
def validate_4(data: Any) -> bool:
    """Utility validate function - conflicts with validate in other modules"""
    if data is None:
        return False
    if isinstance(data, str):
        return len(data) > 0
    elif isinstance(data, (list, dict)):
        return len(data) > 0
    elif isinstance(data, (int, float)):
        return data >= 0
    return True
class Connection_3:
    """Utility connection class - name conflict with database Connection"""

    def __init__(self, connection_type: str="utility"):
        self.connection_type = connection_type
        self.active = False

    def connect(self) -> str:
        self.active = True
        return f"Utility connection: {self.connection_type}"
def connect_2() -> Connection_3:
    """Utility connect function"""
    return Connection_3("helper")
def process_with_conflicts(data: Any, User: str="param_user", result: int=100, Logger: Any=None) -> Dict[str, Any]:
    """Function with parameter names that conflict with globals and imports"""
    connection = connect_2()
    validate_result = validate_4(data)
    local_result = {"data": data, "user_param": User_4, "result_param": result_3, "logger_param": Logger_3, "validation": validate_result, "connection_type": connection.connection_type}
    return local_result
validate_5 = validate_4
process_6 = process_5
Connection_4 = "utils_connection_type"
"""\nBase model functionality with relative import conflicts\n"""
result_4 = "base_result"
process_7 = "base_process_string"
class BaseModel:
    """Base model class with method name conflicts"""

    def __init__(self, model_type: str):
        self.model_type = model_type
        self.initialized = False
        self.validate = self._base_validate
        self.process = self._base_process
        self.Logger = UserLogger("base_model")

    def _base_validate(self, data: Any) -> bool:
        """Base validation using relative imports"""
        return core_validate(data)

    def _base_process(self, data: Any) -> str:
        """Base processing with conflicts"""
        validated = self.validate(data)
        if validated:
            self.Logger._log_process(f"Base processing: {data}")
            return f"base_processed: {data}"
        return "base_invalid"

    def initialize(self) -> str:
        """Initialize with name conflicts"""
        global result
        self.initialized = True
        result_4 = f"base_initialized_{self.model_type}"
        return result_4
def initialize() -> str:
    """Module initialization function"""
    global result
    base = BaseModel("default")
    init_result = base.initialize()
    logger = UserLogger("base_init")
    logger._log_process("Base module initialized")
    result_4 = f"module_init: {init_result}"
    return result_4
def validate_6(data: Any) -> bool:
    """Base validate function - conflicts everywhere"""
    return core_validate(data) and data != "invalid"
def process_8(data: Any) -> str:
    """Base process function - conflicts everywhere"""
    global result
    validated = validate_6(data)
    if validated:
        processed = f"base_module_process: {data}"
    else:
        processed = "base_module_invalid"
    result_4 = f"base_last_process: {processed}"
    return processed
class Logger_4:
    """Base Logger class - yet another Logger conflict"""

    def __init__(self, source: str):
        self.source = source
        self.logs = []

    def log(self, message: str) -> None:
        self.logs.append(f"[BASE {self.source}] {message}")

    def process(self, log_data: Any) -> str:
        """Logger process method - conflicts with global process"""
        self.log(f"Processing: {log_data}")
        return f"base_logger_process: {log_data}"
def connect_3() -> str:
    """Base connect function"""
    return "base_connected"
def shadow_test(validate: Any=None, process: Any=None, Logger: Any=None, result: Any=None, initialize: Any=None) -> Dict[str, Any]:
    """Function that shadows all major conflict names with parameters"""
    shadows = {"validate_param": validate_6, "process_param": process_8, "Logger_param": Logger_4, "result_param": result_4, "initialize_param": initialize}
    validate_6 = globals()["validate"]
    process_8 = globals()["process"]
    Logger_4 = globals()["Logger"]
    validation_result = validate_6("test_data")
    process_result = process_8("test_data")
    logger = Logger_4("shadow_test")
    shadows.update({"global_validate_result": validation_result, "global_process_result": process_result, "global_logger_source": logger.source})
    return shadows
validate_7 = validate_6
process_9 = process_8
Logger_5 = Logger_4
initialize_1 = initialize
connection_3 = "auth_connection_string"
process_10 = "models_process_string"
validate_8 = "models_validate_string"
connection_4 = "models_connection_string"
Logger_6 = "services_logger_string"
result_5 = {"services": "initialized"}
def __cribo_init___cribo_13ff00_services_auth_manager():
    if '__cribo_13ff00_services_auth_manager' in sys.modules:
        return sys.modules['__cribo_13ff00_services_auth_manager']
    module = types.ModuleType('__cribo_13ff00_services_auth_manager')
    module.__file__ = __file__
    sys.modules['__cribo_13ff00_services_auth_manager'] = module
    sys.modules['services.auth.manager'] = module
    """\nAuthentication manager with complex naming conflicts\n"""
    DBConnection = Connection_2
    module.DBConnection = DBConnection
    result = "auth_result"
    module.result = result
    validate = lambda x: f"auth_lambda_validate: {x}"
    module.validate = validate

    class User:
        """Auth User class - conflicts with other User classes/variables"""

        def __init__(self, username: str, password: str):
            self.username = username
            self.password = password
            self.authenticated = False
            self.result = None
            self.connection = None

        def authenticate(self) -> bool:
            """Authenticate user with name conflicts"""
            validate = self._internal_validate
            result = validate(self.password)
            self.authenticated = result
            self.result = f"auth_user_{self.username}_{result}"
            return result

        def _internal_validate(self, password: str) -> bool:
            return len(password) >= 4

        def connect(self) -> str:
            """Method with same name as global functions"""
            self.connection = DBConnection()
            return f"User {self.username} connected"
    module.User = User

    class Connection:
        """Auth connection class - conflicts with DB Connection"""

        def __init__(self, auth_type: str="oauth"):
            self.auth_type = auth_type
            self.users = []

        def add_user(self, User: "User") -> None:
            """Add user with parameter name conflict"""
            self.users.append(User)

        def process(self, User: str) -> str:
            """Process with parameter name conflicts"""
            return f"auth_connection_process: {User}"
    module.Connection = Connection

    def process(data: Any) -> str:
        """Auth process function - major conflict"""
        global result
        base_init = base.initialize()
        if isinstance(data, str):
            validate = lambda x: x.startswith("auth_")
            validated = validate(data)
            processed = f"auth_str_{data}" if validated else f"invalid_auth_{data}"
        else:
            processed = f"auth_other_{data}"
        result = f"{result}_processed"
        return f"auth_processed: {processed}, base: {base_init}"
    module.process = process

    def validate(data: Any) -> str:
        """Auth validate function - conflicts with other validate functions"""
        if not data:
            return "auth_invalid"
        global_validate = globals().get("validate", lambda x: f"fallback_{x}")
        lambda_result = global_validate(data) if callable(global_validate) else str(data)
        return f"auth_valid: {data}, lambda: {lambda_result}"
    module.validate = validate

    def connect(User: Optional["User"]=None) -> Connection:
        """Connect function with parameter conflict"""
        connection = Connection("auth_manager")
        if User:
            connection.add_user(User)
        return connection
    module.connect = connect

    class AuthManager:
        """Manager class with extensive conflicts"""

        def __init__(self):
            self.connections = []
            self.users = []
            self.process = self._manager_process
            self.validate = self._manager_validate
            self.User = None

        def _manager_process(self, data: Any) -> str:
            return f"manager_process: {data}"

        def _manager_validate(self, data: Any) -> bool:
            return data is not None

        def add_user(self, username: str, password: str) -> "User":
            """Method that creates User with local scope conflicts"""
            User = globals()["User"]
            user = User(username, password)
            self.users.append(user)
            self.User = user
            return user

        def process_all(self) -> Dict[str, Any]:
            """Method using conflicting names throughout"""
            result = []
            for User in self.users:
                user_result = process(User.username)
                validate_result = validate(User.password)
                connection = connect(User)
                connection_process = connection.process(User.username)
                result.append({"user": User.username, "process": user_result, "validate": validate_result, "connection": connection_process})
            return {"manager_results": result}
    module.AuthManager = AuthManager
    process = process
    module.process = process
    validate = validate
    module.validate = validate
    User = User
    module.User = User
    return module
def __cribo_init___cribo_62c387_core():
    if '__cribo_62c387_core' in sys.modules:
        return sys.modules['__cribo_62c387_core']
    module = types.ModuleType('__cribo_62c387_core')
    module.__file__ = __file__
    sys.modules['__cribo_62c387_core'] = module
    sys.modules['core'] = module
    CoreLogger = Logger_3
    module.CoreLogger = CoreLogger
    core_process = process_6
    module.core_process = core_process
    result = "core_package_result"
    module.result = result
    Logger = CoreLogger
    module.Logger = Logger
    return module
__cribo_modules = {'services.auth.manager': '__cribo_13ff00_services_auth_manager', 'core': '__cribo_62c387_core'}
__cribo_init_functions = {'__cribo_13ff00_services_auth_manager': __cribo_init___cribo_13ff00_services_auth_manager, '__cribo_62c387_core': __cribo_init___cribo_62c387_core}
class CriboBundledFinder:

    def __init__(self, module_registry, init_functions):
        self.module_registry = module_registry
        self.init_functions = init_functions

    def find_spec(self, fullname, path, target=None):
        if fullname in self.module_registry:
            synthetic_name = self.module_registry[fullname]
            if synthetic_name not in sys.modules:
                init_func = self.init_functions.get(synthetic_name)
                if init_func:
                    init_func()
            import importlib.util
            return importlib.util.find_spec(synthetic_name)
        return None
sys.meta_path.insert(0, CriboBundledFinder(__cribo_modules, __cribo_init_functions))
__cribo_init___cribo_13ff00_services_auth_manager()
__cribo_init___cribo_62c387_core()
"""\nComprehensive AST rewriter test fixture - Main entry point\nThis module demonstrates complex naming conflicts and import scenarios\n"""
db_process = process_4
process = process_6
UtilLogger = Logger_3
validate = validate_5
auth_process = sys.modules['services.auth.manager'].process
User = sys.modules['services.auth.manager'].User
auth_validate = sys.modules['services.auth.manager'].validate
UserModel = User_2
Logger = Logger_2
from main.models import base
result = 42
connection = None
Logger = "string_logger"
def validate(data):
    """This validate function conflicts with imported validate functions"""
    return f"main_validate: {data}"
def process():
    """This process function conflicts with multiple imported process functions"""
    return "main_process"
class User:
    """This User class conflicts with imported User classes"""

    def __init__(self, name):
        self.name = name
        self.result = self._process_name(name)

    def _process_name(self, name):
        return f"main_user: {name}"
class Connection:
    """Connection class that conflicts with database connection"""

    def __init__(self):
        self.status = "disconnected"

    def connect(self):
        global connection
        connection = self
        return "main_connection_established"
def main():
    """Main function demonstrating all the conflicts in action"""
    db_result = db_process("database_data")
    util_result = process("utility_data")
    auth_result = auth_process("auth_data")
    util_logger = UtilLogger("util")
    model_logger = Logger("model")
    auth_user = User("auth_type")
    model_user = UserModel("model_type")
    service_user = User("service_type", "password")
    local_validate_result = validate("local_data")
    auth_validate_result = auth_validate("auth_data")
    util_validate_result = validate("util_data")
    result = db_result + util_result + auth_result
    base_result = base.initialize()
    final_result = {"process_results": [db_result, util_result, auth_result], "validation_results": [local_validate_result, auth_validate_result, util_validate_result], "user_types": [auth_user.name, model_user.name, service_user.username], "logger_messages": [util_logger.get_message(), model_logger.get_message()], "base_init": base_result, "total": result + globals()["result"]}
    return final_result
if __name__ == "__main__":
    connection = Connection()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
