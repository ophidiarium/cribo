---
source: crates/cribo/tests/test_bundling_snapshots.rs
input_file: crates/cribo/tests/fixtures/multiline_strings/main.py
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

import sys as _sys
import importlib as _importlib
class _CriboModule():

    def __init__(self, m, p):
        self._m, self._p = m, p

    def __getattr__(self, n):
        f = self._p + '.' + n
        try:
            return _CriboModule(_importlib.import_module(f), f)
        except ImportError:
            return getattr(self._m, n)

    def __getattribute__(self, n):
        return object.__getattribute__(self, n) if n in ('_m', '_p', '__getattr__', '__class__', '__dict__', '__dir__', '__module__', '__qualname__') else getattr(object.__getattribute__(self, '_m'), n)
class _Cribo():

    def __getattr__(self, n):
        m = _sys.modules.get(n) or _importlib.import_module(n)
        return _CriboModule(m, n)
_cribo = _Cribo()
strings_inline = _cribo.types.SimpleNamespace(__name__='strings_inline', __doc__='Inline-only module mixing multiline literal patterns.')
"""Inline-only module mixing multiline literal patterns."""
HEADER = '''Inline Section\n- maintains indentation\n- uses single quotes\n'''
DOUBLE_QUOTED = """Double-quoted block demonstrating nested 'single quotes'\nand maintaining the original quoting style.\n"""
TAIL = """Trailing piece\n    spans multiple\n    lines\n    """ "with extra info\n"
def format_report(data: dict[str, object]) -> str:
    """Combine multiline pieces into final string."""
    body = f"""Report:\n    name={data['name']}\n    value={data['value']}\n    """
    extra = f'''Summary:\n    keys={", ".join(data.keys())}\n    '''
    return HEADER + DOUBLE_QUOTED + body + TAIL + extra
strings_inline.DOUBLE_QUOTED = DOUBLE_QUOTED
strings_inline.HEADER = HEADER
strings_inline.TAIL = TAIL
strings_inline.format_report = format_report
side_effect_module = _cribo.types.SimpleNamespace(__name__='side_effect_module', __initializing__=False, __initialized__=False)
def _cribo_init___cribo_2f952c_side_effect_module(self):
    if getattr(self, '__initialized__', False):
        return self
    if getattr(self, '__initializing__', False):
        return self
    self.__initializing__ = True
    """Module with side effects and diverse multiline literals."""
    START_BANNER = """Loading side effect module:\n    - timestamps\n    - values\n"""
    self.START_BANNER = START_BANNER
    DETAILS = '''        Captured context:\n        module={__name__}\n    ''' "        status=ready"
    self.DETAILS = DETAILS

    def _render_start() -> str:
        """Produce a multiline message with runtime data."""
        message = f"""Start Time:\n    2024-01-02 03:04:05\n    Module: multiline_strings.side_effect_module\n    Status: {"ready"}\n    """
        more = """Computed Values:\n        length=62\n    """
        note = """Generated output\n        includes a blank line\n        """ "appended"
        return message + more + note
    self._render_start = _render_start
    SUMMARY_TEXT = START_BANNER + DETAILS
    self.SUMMARY_TEXT = SUMMARY_TEXT
    print(_render_start())
    self.__initialized__ = True
    self.__initializing__ = False
    return self
side_effect_module.__init__ = _cribo_init___cribo_2f952c_side_effect_module
docstring_module = _cribo.types.SimpleNamespace(__name__='docstring_module', __doc__='Module demonstrating multiline docstrings preservation.\n\nThis docstring spans multiple lines and contains:\n    - Indented sections\n    - Special characters: "quotes", \'apostrophes\', and symbols !@#$%\n    - Empty lines above\n')
"""Module demonstrating multiline docstrings preservation.\n\nThis docstring spans multiple lines and contains:\n    - Indented sections\n    - Special characters: \"quotes\", 'apostrophes', and symbols !@#$%\n    - Empty lines above\n"""
def simple_function():
    """Single line docstring for simple function."""
    return "simple"
def multiline_function(x: int, y: int) -> int:
    """Calculate the sum of two numbers.\n\n    Args:\n        x: First number\n        y: Second number\n\n    Returns:\n        The sum of x and y\n\n    Examples:\n        >>> multiline_function(1, 2)\n        3\n    """
    return x + y
def indented_docstring():
    """\n    This docstring has intentional indentation patterns:\n        - Indented list item 1\n        - Indented list item 2\n            - Nested item\n\n    Code example:\n        def example():\n            return True\n\n    More text after code block.\n    """
    return "indented"
class DocumentedClass:
    """A class with comprehensive documentation.\n\n    This class demonstrates various docstring patterns:\n        - Class-level documentation\n        - Method documentation\n        - Special method documentation\n\n    Attributes:\n        value: An integer value\n        name: A string identifier\n    """

    def __init__(self, value: int, name: str):
        """Initialize the DocumentedClass.\n\n        Args:\n            value: The initial value\n            name: The name identifier\n        """
        self.value = value
        self.name = name

    def get_info(self) -> str:
        """Return formatted information about this instance.\n\n        Returns:\n            A multiline string containing:\n                - The instance name\n                - The instance value\n                - Additional metadata\n        """
        return f"""Instance Info:\n    name={self.name}\n    value={self.value}\n    type={type(self).__name__}\n"""

    @staticmethod
    def static_method():
        """Static method with docstring.\n\n        This method doesn't access instance state.\n        It exists to demonstrate static method docstrings.\n        """
        return "static"

    @classmethod
    def class_method(cls):
        """Class method with docstring.\n\n        Returns:\n            The class name as a string.\n        """
        return cls.__name__
DocumentedClass.__module__ = 'docstring_module'
def triple_quoted_variations():
    '''This docstring uses single triple quotes.\n\n    It should be preserved identically to double-quoted docstrings.\n    Special characters: "double quotes" work fine here.\n    '''
    return "single-triple-quoted"
def docstring_with_formatting():
    """\n    ╔═══════════════════════════════════╗\n    ║  Fancy Box-Drawing Characters     ║\n    ╠═══════════════════════════════════╣\n    ║  - Unicode support                ║\n    ║  - Special formatting             ║\n    ║  - Emoji: 🎯 ✅ 🚀                ║\n    ╚═══════════════════════════════════╝\n\n    This tests preservation of:\n        • Unicode box-drawing characters\n        • Emoji and special symbols\n        • Mixed indentation levels\n    """
    return "formatted"
"""This is a module-level constant docstring.\n\nConstants can have docstrings too, though they're less common.\nThis tests that such docstrings are preserved.\n"""
docstring_module.DocumentedClass = DocumentedClass
docstring_module.docstring_with_formatting = docstring_with_formatting
docstring_module.indented_docstring = indented_docstring
docstring_module.multiline_function = multiline_function
docstring_module.simple_function = simple_function
docstring_module.triple_quoted_variations = triple_quoted_variations
"""Entry point exercising multiline string handling across modules."""
side_effect_module = _cribo_init___cribo_2f952c_side_effect_module(side_effect_module)
def validate_docstring(obj, expected_keywords: list[str], label: str) -> None:
    """Validate that an object's docstring contains expected content.\n\n    Args:\n        obj: The object (function, class, etc.) to validate\n        expected_keywords: List of strings that must appear in the docstring\n        label: Human-readable label for the validation\n    """
    doc = obj.__doc__
    if doc is None:
        print(f"❌ {label}: Missing docstring")
        return
    missing = [kw for kw in expected_keywords if kw not in doc]
    if missing:
        print(f"❌ {label}: Missing keywords: {missing}")
        print(f"   Docstring preview: {doc[:100]}...")
    else:
        print(f"✅ {label}: Docstring validated ({len(doc)} chars)")
def main() -> None:
    data = {"name": "Cribo", "value": 42}
    print(format_report(data))
    print(side_effect_module.SUMMARY_TEXT)
    print("\n" + "=" * 60)
    print("DOCSTRING VALIDATION")
    print("=" * 60)
    validate_docstring(docstring_module, ["multiline docstrings preservation", "Indented sections", "Special characters"], "Module docstring")
    validate_docstring(docstring_module.simple_function, ["Single line docstring"], "Simple function")
    validate_docstring(docstring_module.multiline_function, ["Args:", "Returns:", "Examples:"], "Multiline function")
    validate_docstring(docstring_module.indented_docstring, ["intentional indentation", "Code example:", "def example():"], "Indented docstring")
    validate_docstring(docstring_module.DocumentedClass, ["comprehensive documentation", "Attributes:", "value:", "name:"], "Class docstring")
    validate_docstring(docstring_module.DocumentedClass.__init__, ["Initialize", "Args:"], "Class __init__")
    validate_docstring(docstring_module.DocumentedClass.get_info, ["formatted information", "Returns:", "A multiline string"], "Class method")
    validate_docstring(docstring_module.DocumentedClass.static_method, ["Static method", "doesn't access instance state"], "Static method")
    validate_docstring(docstring_module.DocumentedClass.class_method, ["Class method", "Returns:", "class name"], "Class method decorator")
    validate_docstring(docstring_module.triple_quoted_variations, ["single triple quotes", "double quotes"], "Triple-quoted variations")
    validate_docstring(docstring_module.docstring_with_formatting, ["╔═══════", "Unicode", "Emoji: 🎯"], "Formatted docstring")
    print("\n" + "=" * 60)
    print("SAMPLE DOCSTRING CONTENT")
    print("=" * 60)
    print("\n--- Module Docstring (first 200 chars) ---")
    print(docstring_module.__doc__[:200])
    print("\n--- Class Docstring ---")
    print(docstring_module.DocumentedClass.__doc__)
    print("\n--- Method Docstring ---")
    print(docstring_module.DocumentedClass.get_info.__doc__)
    print("\n--- Formatted Docstring Preview ---")
    print(docstring_module.docstring_with_formatting.__doc__[:300])
    instance = docstring_module.DocumentedClass(42, "test")
    print("\n--- Instance Method Output ---")
    print(instance.get_info())
if __name__ == "__main__":
    main()
