---
source: crates/cribo/tests/test_bundling_snapshots.rs
input_file: crates/cribo/tests/fixtures/bundling/xfail_mixed_import_patterns/main.py
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

import sys
import types
"""\nConfiguration module that logs its initialization process.\nThis creates a circular dependency: config -> logger -> config\n"""
class Config:

    def __init__(self):
        self.debug_mode = True
        self.app_name = "CircularImportDemo"
        self.version = "1.0.0"
        self._logger_configured = False
        logger = get_logger()
        logger.log("Initializing configuration system")

    def ensure_logger_configured(self):
        """Configure logger after config is ready"""
        if not self._logger_configured:
            logger = get_logger()
            logger.configure()
            logger.log("Configuration system initialized", "INFO")
            self._logger_configured = True

    def get_setting(self, key):
        return getattr(self, key, None)
def get_config():
    global _config
    if _config is None:
        _config = Config()
    return _config
def get_log_level():
    """Get log level from config - used by logger module"""
    if _config is None:
        return "INFO"
    return "DEBUG" if _config.debug_mode else "INFO"
"""\nUtility module with no dependencies on other modules in this package.\nThis can be safely imported at module level by everyone.\n"""
def format_message(message):
    """Format a message with decorative borders"""
    return f">>> {message} <<<"
def get_timestamp():
    """Get current timestamp for logging"""
    return "00:00:00"
__cribo_logger__logger = None
def __cribo_init___cribo_94bd20_app():
    if '__cribo_94bd20_app' in sys.modules:
        return sys.modules['__cribo_94bd20_app']
    module = types.ModuleType('__cribo_94bd20_app')
    module.__file__ = __file__ if '__file__' in globals() else None
    sys.modules['__cribo_94bd20_app'] = module
    sys.modules['app'] = module
    """\nApplication module that uses both config and logger.\nNo circular dependencies here - just normal imports.\n"""
    module.get_config = get_config
    get_logger = sys.modules['logger'].get_logger
    module.get_logger = get_logger
    module.format_message = format_message

    class Application:

        def __init__(self):
            self.config = get_config()
            self.logger = get_logger()
            self.logger.log(f"Creating {self.config.app_name} v{self.config.version} application instance")

        def run(self):
            """Run the application with various logging examples"""
            self.logger.log("Application.run() called", "DEBUG")
            print(format_message("Performing application tasks..."))
            self.demonstrate_import_patterns()
            self.logger.log("Application tasks completed", "INFO")

        def demonstrate_import_patterns(self):
            """Show how the same module can be imported different ways"""
            self.logger.log("Using module-level logger import", "DEBUG")
            print(format_message("Mixed import patterns working correctly!"))
            from logger import get_logger
            local_logger = get_logger()
            local_logger.log("Function-level import gives same logger instance", "DEBUG")
    module.Application = Application
    return module
def __cribo_init___cribo_0639af_logger():
    if '__cribo_0639af_logger' in sys.modules:
        return sys.modules['__cribo_0639af_logger']
    module = types.ModuleType('__cribo_0639af_logger')
    module.__file__ = __file__ if '__file__' in globals() else None
    sys.modules['__cribo_0639af_logger'] = module
    sys.modules['logger'] = module
    """\nLogger module that needs configuration to determine log level.\nThis creates a circular dependency: logger -> config -> logger\n"""
    module.format_message = format_message
    module.get_timestamp = get_timestamp

    class Logger:

        def __init__(self):
            self.log_level = "INFO"
            print(format_message("[Logger] Initializing logger system"))

        def configure(self):
            """Configure logger with settings from config module"""
            from config import get_log_level
            self.log_level = get_log_level()
            self.log(f"Logger configured with level: {self.log_level}")

        def log(self, message, level="INFO"):
            if self._should_log(level):
                print(f"[{level}] {message}")

        def _should_log(self, level):
            levels = {"DEBUG": 0, "INFO": 1, "WARNING": 2, "ERROR": 3}
            return levels.get(level, 1) >= levels.get(self.log_level, 1)
    module.Logger = Logger
    _logger = None

    def get_logger():
        global __cribo_logger__logger
        _logger = __cribo_logger__logger
        if __cribo_logger__logger is None:
            __cribo_logger__logger = Logger()
        return __cribo_logger__logger
    module.get_logger = get_logger
    global __cribo_logger__logger
    __cribo_logger__logger = _logger
    return module
__cribo_modules = {'app': '__cribo_94bd20_app', 'logger': '__cribo_0639af_logger'}
__cribo_init_functions = {'__cribo_94bd20_app': __cribo_init___cribo_94bd20_app, '__cribo_0639af_logger': __cribo_init___cribo_0639af_logger}
class CriboBundledFinder:

    def __init__(self, module_registry, init_functions):
        self.module_registry = module_registry
        self.init_functions = init_functions

    def find_spec(self, fullname, path, target=None):
        if fullname in self.module_registry:
            synthetic_name = self.module_registry[fullname]
            if synthetic_name not in sys.modules:
                init_func = self.init_functions.get(synthetic_name)
                if init_func:
                    init_func()
            import importlib.util
            return importlib.util.find_spec(synthetic_name)
        return None
sys.meta_path.insert(0, CriboBundledFinder(__cribo_modules, __cribo_init_functions))
__cribo_init___cribo_94bd20_app()
__cribo_init___cribo_0639af_logger()
"""\nSimulates a software architecture with:\n- A logger that needs configuration\n- A configuration system that logs its initialization\n- An application that uses both\n- Utilities that are used everywhere (no circular deps)\n"""
def main():
    print(format_message("=== Application Starting ==="))
    from config import Config
    config = Config()
    config.ensure_logger_configured()
    print(format_message(f"Configuration loaded: debug={config.debug_mode}"))
    from app import Application
    app = Application()
    app.run()
    print(format_message("=== Application Finished ==="))
if __name__ == "__main__":
    main()
