---
source: crates/cribo/tests/test_bundling_snapshots.rs
input_file: crates/cribo/tests/fixtures/xfail_cross_package_mixed_import/main.py
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

import types
def safe_connect(database_name: str) -> str:
    """Connect only if core is initialized."""
    from .. import is_initialized
    if not is_initialized():
        raise RuntimeError("Core package must be initialized before connecting")
    return connect(database_name)
def validate_db_name(name: str) -> bool:
    """Validate database name with additional rules."""
    if not validate(name):
        return False
    return not any(char in name for char in ["/", "\\", ":"])
def _register_type(type_name):
    """Internal function to register database types."""
    _registered_types.append(type_name)
    return type_name
def validate_db_name(name: str) -> bool:
    """Validate database name with additional rules."""
    if not validate(name):
        return False
    return not any(char in name for char in ["/", "\\", ":"])
_registered_types = []
def safe_connect(database_name: str) -> str:
    """Connect only if core is initialized."""
    from .. import is_initialized
    if not is_initialized():
        raise RuntimeError("Core package must be initialized before connecting")
    return connect(database_name)
__all___core_database = ["connect", "get_connection_info", "safe_connect", "validate_db_name", "_registered_types"]
_register_type("connection")
core_database = types.SimpleNamespace()
core_database.validate_db_name = validate_db_name
core_database.safe_connect = safe_connect
if HAS_ADVANCED:
    __all__.append("AdvancedModel")
def get_model_version_models():
    """Get the models package version."""
    return _VERSION
if sys.version_info >= (3, 9):
    from typing import TypeAlias
    ModelID: TypeAlias = str
else:
    ModelID = str
def get_base_model():
    """Lazy import of BaseModel to avoid circular imports."""
    global _base_model
    if _base_model is None:
        from .base import BaseModel
        _base_model = BaseModel
    return _base_model
if sys.version_info >= (3, 9):
    from typing import TypeAlias
    ModelID: TypeAlias = str
else:
    ModelID = str
__all___models = ["get_model_version", "process_user", "get_base_model", "ModelID", "DEFAULT_MODEL_CONFIG", "HAS_ADVANCED"]
_VERSION = "1.0.0"
def get_base_model():
    """Lazy import of BaseModel to avoid circular imports."""
    global _base_model
    if _base_model is None:
        from .base import BaseModel
        _base_model = BaseModel
    return _base_model
if HAS_ADVANCED:
    __all__.append("AdvancedModel")
if sys.version_info >= (3, 9):
    from typing import TypeAlias
    ModelID: TypeAlias = str
else:
    ModelID = str
models = types.SimpleNamespace()
models.get_model_version = get_model_version_models
models.ModelID = ModelID
models.ModelID = ModelID
models.get_base_model = get_base_model
def initialize_core_core(debug=False):
    """Initialize the core package with configuration."""
    global _initialized, _config
    _initialized = True
    _config["debug"] = debug
    if debug:
        print(f"Core initialized with version: {CORE_MODEL_VERSION}")
    return _initialized
__all__ = ["initialize_core", "is_initialized", "validate", "get_config", "CORE_MODEL_VERSION"]
set_config_reference(_config)
_config = {"debug": False}
def is_initialized():
    """Check if core is initialized."""
    return _initialized
_initialized = False
def initialize_core_core(debug=False):
    """Initialize the core package with configuration."""
    global _initialized, _config
    _initialized = True
    _config["debug"] = debug
    if debug:
        print(f"Core initialized with version: {CORE_MODEL_VERSION}")
    return _initialized
core = types.SimpleNamespace()
core.initialize_core = initialize_core_core
core.is_initialized = is_initialized
class Connection:
    """Connection class using mixed imports."""

    def __init__(self, database_name: str):
        if not helper_validate(database_name) or any(char in database_name for char in ["/", "\\", ":"]):
            raise ValueError(f"Invalid database name: {database_name}")
        self.name = process_user(database_name)
        self.metadata = CONNECTION_METADATA.copy()
        if database_name.startswith("model_"):
            BaseModel = get_base_model()
            self.model = BaseModel(database_name)
            self.metadata["model_info"] = self.model.get_info()

    def __str__(self):
        return f"Connection to {self.name}"
def get_connection_info_core_database_connection() -> dict:
    """Get general connection information."""
    from ..utils.config import is_debug
    info = {"metadata": CONNECTION_METADATA, "debug_mode": is_debug(), "available_validators": ["validate_db_name", helper_validate.__name__]}
    if is_debug():
        from ..utils.config import get_config as get_full_config
        info["config"] = get_full_config()
    return info
class Connection:
    """Connection class using mixed imports."""

    def __init__(self, database_name: str):
        if not helper_validate(database_name) or any(char in database_name for char in ["/", "\\", ":"]):
            raise ValueError(f"Invalid database name: {database_name}")
        self.name = process_user(database_name)
        self.metadata = CONNECTION_METADATA.copy()
        if database_name.startswith("model_"):
            BaseModel = get_base_model()
            self.model = BaseModel(database_name)
            self.metadata["model_info"] = self.model.get_info()

    def __str__(self):
        return f"Connection to {self.name}"
class Connection:
    """Connection class using mixed imports."""

    def __init__(self, database_name: str):
        if not helper_validate(database_name) or any(char in database_name for char in ["/", "\\", ":"]):
            raise ValueError(f"Invalid database name: {database_name}")
        self.name = process_user(database_name)
        self.metadata = CONNECTION_METADATA.copy()
        if database_name.startswith("model_"):
            BaseModel = get_base_model()
            self.model = BaseModel(database_name)
            self.metadata["model_info"] = self.model.get_info()

    def __str__(self):
        return f"Connection to {self.name}"
_connection_types = ["standard", "pooled", "async"]
def get_connection_info_core_database_connection() -> dict:
    """Get general connection information."""
    from ..utils.config import is_debug
    info = {"metadata": CONNECTION_METADATA, "debug_mode": is_debug(), "available_validators": ["validate_db_name", helper_validate.__name__]}
    if is_debug():
        from ..utils.config import get_config as get_full_config
        info["config"] = get_full_config()
    return info
core_database_connection = types.SimpleNamespace()
core_database_connection.get_connection_info = get_connection_info_core_database_connection
core_database_connection.Connection = Connection
def process_user(name: str) -> str:
    """Process a user-related string.\n\n    This function is imported by core.database.connection,\n    demonstrating a cross-package absolute import.\n    """
    return f"user_{name}_processed"
models_user = types.SimpleNamespace()
models_user.process_user = process_user
connect = core_database_connection.connect
get_connection_info = core_database_connection.get_connection_info
CONNECTION_METADATA = core_database_connection.CONNECTION_METADATA
initialize_core = core.initialize_core
get_model_version = models.get_model_version
DEFAULT_MODEL_CONFIG = models.DEFAULT_MODEL_CONFIG
HAS_ADVANCED = models.HAS_ADVANCED
db_connect = core_database.connect
validate = core.validate
get_config = core.get_config
"""Test fixture demonstrating cross-package mixed import patterns.\n\nThis tests the specific pattern where a module uses both:\n1. Deep absolute imports crossing package boundaries (e.g., from models.user)\n2. Relative imports within its package (e.g., from ..utils.helpers)\n3. Import order dependencies with __init__.py files\n"""
def demonstrate_import_patterns():
    """Demonstrate various import pattern behaviors."""
    print("=== Import Pattern Demonstration ===")
    print(f"\n1. Import-time values:")
    print(f"   - Model version from models package: {get_model_version()}")
    print(f"   - Core model version: {CONNECTION_METADATA['core_version']}")
    print(f"   - Model config features: {DEFAULT_MODEL_CONFIG['features']}")
    print(f"   - Has advanced model: {HAS_ADVANCED}")
    print(f"\n2. Pre-initialization state:")
    print(f"   - Config before init: {get_config()}")
    initialize_core(debug=True)
    print(f"\n3. Post-initialization state:")
    print(f"   - Config after init: {get_config()}")
    print(f"\n4. Testing connections:")
    conn1 = connect("test_db")
    print(f"   - Direct import: {conn1}")
    conn2 = db_connect("prod_db")
    print(f"   - Package-level import: {conn2}")
    conn3 = connect("model_user_db")
    print(f"   - With lazy import: {conn3}")
    info = get_connection_info()
    print(f"\n5. Connection info shows all imports:")
    print(f"   - Debug mode: {info['debug_mode']}")
    print(f"   - Available validators: {info['available_validators']}")
    print(f"   - Metadata processor: {info['metadata']['processor']}")
    print(f"   - Config included: {'config' in info}")
    return info
def main():
    """Main entry point."""
    results = demonstrate_import_patterns()
    print(f"\n6. Package-level re-exports:")
    print(f"   - validate('test'): {validate('test')}")
    print(f"   - validate('_hidden'): {validate('_hidden')}")
    return results
if __name__ == "__main__":
    result = main()
    print(f"\n=== Final Result ===")
    print(f"Successfully demonstrated cross-package mixed import patterns")
if __name__ == "__main__":
    result = main()
    print(f"\n=== Final Result ===")
    print(f"Successfully demonstrated cross-package mixed import patterns")
if __name__ == "__main__":
    result = main()
    print(f"\n=== Final Result ===")
    print(f"Successfully demonstrated cross-package mixed import patterns")
if __name__ == "__main__":
    result = main()
    print(f"\n=== Final Result ===")
    print(f"Successfully demonstrated cross-package mixed import patterns")
