---
source: crates/cribo/tests/test_bundling_snapshots.rs
---
ExecutionResults {
    status: Failed(
        1,
    ),
    stdout: "",
    stderr: "Traceback (most recent call last):\n  File \"<TMP>/bundled.py\", line 24, in <module>\n    exec('process = process\\n\"\"\"\\\\nUser model with extensive naming conflicts across the project\\\\n\"\"\"\\nresult = {\"model\": \"user\"}\\n__models_user_connection = None\\nclass Logger:\\n    \"\"\"Model Logger class - conflicts with other Logger classes\"\"\"\\n\\n    def __init__(self, context: str):\\n        self.context = context\\n        self.entries = []\\n        self.process = self._log_process\\n\\n    def _log_process(self, message: str) -> None:\\n        self.entries.append(f\"{self.context}: {message}\")\\n\\n    def get_message(self) -> str:\\n        return f\"Model Logger: {self.context}\"\\n\\n    def __models_user_validate(self, entry: str) -> bool:\\n        \"\"\"Method with name that conflicts with global functions\"\"\"\\n        return len(entry) > 0\\nclass __models_user_User:\\n    \"\"\"Model User class - major conflict with other User classes\"\"\"\\n\\n    def __init__(self, name: str, email: str=\"\"):\\n        self.name = name\\n        self.email = email\\n        self.active = True\\n        self.Logger = Logger(f\"user_{name}\")\\n        self.process = self._user_process\\n        self.validate = self._user_validate\\n        self.result = None\\n\\n    def _user_process(self, data: Any) -> str:\\n        \"\"\"Private method using conflicted names\"\"\"\\n        util_result = util_process(data)\\n        self.Logger.validate(str(data))\\n        self.Logger._log_process(f\"Processing: {data}\")\\n        self.result = f\"user_model_process: {util_result}\"\\n        return self.result\\n\\n    def _user_validate(self, field: str, value: Any) -> bool:\\n        \"\"\"Private validation with name conflicts\"\"\"\\n        if field == \"name\":\\n            return isinstance(value, str) and len(value) > 0\\n        elif field == \"email\":\\n            return \"@\" in str(value) if value else True\\n        return False\\n\\n    def authenticate(self, password: str) -> Dict[str, Any]:\\n        \"\"\"Method with complex internal conflicts\"\"\"\\n        __models_user_validate = self.validate\\n        __models_user_process = self.process\\n        Logger = self.Logger\\n        result = {}\\n        name_valid = __models_user_validate(\"name\", self.name)\\n        email_valid = __models_user_validate(\"email\", self.email)\\n        password_valid = len(password) >= 4\\n        auth_data = {\"name\": self.name, \"email\": self.email, \"password_length\": len(password)}\\n        process_result = __models_user_process(auth_data)\\n        Logger.validate(f\"auth_{self.name}\")\\n        result = {\"user\": self.name, \"valid\": name_valid and email_valid and password_valid, \"process_result\": process_result, \"logger_context\": Logger.context}\\n        return result\\n\\n    def __models_user_connect(self) -> str:\\n        \"\"\"Method with name that conflicts with global functions\"\"\"\\n        global connection\\n        __models_user_connection = f\"user_model_connection_{self.name}\"\\n        return __models_user_connection\\ndef process_user(data: Any) -> str:\\n    \"\"\"Module function with naming conflicts\"\"\"\\n    global result\\n    Logger = globals()[\"Logger\"]\\n    __models_user_validate = lambda x: x is not None\\n    logger = Logger(\"process_user\")\\n    is_valid = __models_user_validate(data)\\n    if is_valid:\\n        logger._log_process(f\"Processing user data: {data}\")\\n        processed = f\"model_user_processed: {data}\"\\n    else:\\n        processed = \"model_user_invalid_data\"\\n    result[\"last_process\"] = processed\\n    return processed\\ndef __models_user_validate(user_data: Dict[str, Any]) -> bool:\\n    \"\"\"Module validate function - conflicts with other validates\"\"\"\\n    required_fields = [\"name\"]\\n    return all(field in user_data for field in required_fields)\\ndef __models_user_process(data: Any) -> str:\\n    \"\"\"Module process function - major conflict\"\"\"\\n    if isinstance(data, dict):\\n        return process_user(data)\\n    else:\\n        return f\"model_process_generic: {data}\"\\nclass Connection:\\n    \"\"\"Model connection class - conflicts with other Connection classes\"\"\"\\n\\n    def __init__(self, User: \"User\"):\\n        self.User = __models_user_User\\n        self.connected = False\\n\\n    def __models_user_connect(self) -> str:\\n        self.connected = True\\n        return f\"Model connection for user: {self.User.name}\"\\n\\n    def __models_user_process(self, action: str) -> str:\\n        \"\"\"Method with conflicted name\"\"\"\\n        return f\"connection_process: {action} for {self.User.name}\"\\ndef __models_user_connect(User: \"User\") -> Connection:\\n    \"\"\"Module connect function with parameter conflicts\"\"\"\\n    return Connection(__models_user_User)\\ndef complex_operation(User: Any=None, Logger: Any=None, process: Any=None, validate: Any=None, result: Any=None, connection: Any=None) -> Dict[str, Any]:\\n    \"\"\"Function with all parameter names conflicting with globals/classes\"\"\"\\n    operation_result = {\"user_param\": User, \"logger_param\": Logger, \"process_param\": process, \"validate_param\": validate, \"result_param\": result, \"connection_param\": connection}\\n    __models_user_User = globals()[\"User\"]\\n    Logger = globals()[\"Logger\"]\\n    if operation_result[\"user_param\"]:\\n        user = __models_user_User(\"complex_user\")\\n        logger = Logger(\"complex_operation\")\\n        operation_result[\"created_user\"] = user.name\\n        operation_result[\"created_logger\"] = logger.context\\n    return operation_result\\n__models_user_process = __models_user_process\\n__models_user_validate = __models_user_validate\\n__models_user_User = __models_user_User\\nLogger = Logger', globals(), models.user.__dict__)\n  File \"<string>\", line 1, in <module>\nNameError: name 'process' is not defined",
}
