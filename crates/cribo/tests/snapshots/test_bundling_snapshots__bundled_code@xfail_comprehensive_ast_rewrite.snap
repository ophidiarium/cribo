---
source: crates/cribo/tests/test_bundling_snapshots.rs
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

# ─ Module: core.utils.helpers ─
import types
core = types.ModuleType('core')
core.utils = types.ModuleType('core.utils')
core.utils.helpers = types.ModuleType('core.utils.helpers')
exec('"""\\nUtility helpers module with extensive naming conflicts\\n"""\nfrom typing import Any, Dict, List\n__core_utils_helpers_result = 0\n__core_utils_helpers_User = "helper_user_string"\nclass __core_utils_helpers_Logger:\n    """Utility logger class - conflicts with other Logger classes"""\n\n    def __init__(self, name: str):\n        self.name = name\n        self.messages: List[str] = []\n        self.User = __core_utils_helpers_User\n\n    def log(self, message: str) -> None:\n        self.messages.append(f"[{self.name}] {message}")\n\n    def get_message(self) -> str:\n        return f"Utils Logger: {self.name}"\n\n    def process(self, data: Any) -> str:\n        """Method with same name as module functions"""\n        return f"logger_process: {data}"\ndef process(data: Any) -> str:\n    """Utility process function - major conflict with other process functions"""\n    global result\n    if isinstance(data, str):\n        processed = data.upper()\n    elif isinstance(data, (int, float)):\n        processed = data * 2\n    elif isinstance(data, dict):\n        processed = {k: f"util_{v}" for k, v in data.items()}\n    else:\n        processed = str(data)\n    __core_utils_helpers_result += 1\n    return f"util_processed: {processed}"\ndef validate(data: Any) -> bool:\n    """Utility validate function - conflicts with validate in other modules"""\n    if data is None:\n        return False\n    if isinstance(data, str):\n        return len(data) > 0\n    elif isinstance(data, (list, dict)):\n        return len(data) > 0\n    elif isinstance(data, (int, float)):\n        return data >= 0\n    return True\nclass __core_utils_helpers_Connection:\n    """Utility connection class - name conflict with database Connection"""\n\n    def __init__(self, connection_type: str="utility"):\n        self.connection_type = connection_type\n        self.active = False\n\n    def __core_utils_helpers_connect(self) -> str:\n        self.active = True\n        return f"Utility connection: {self.connection_type}"\ndef __core_utils_helpers_connect() -> __core_utils_helpers_Connection:\n    """Utility connect function"""\n    return __core_utils_helpers_Connection("helper")\ndef process_with_conflicts(data: Any, User: str="param_user", result: int=100, Logger: Any=None) -> Dict[str, Any]:\n    """Function with parameter names that conflict with globals and imports"""\n    connection = __core_utils_helpers_connect()\n    validate_result = validate(data)\n    local_result = {"data": data, "user_param": User, "result_param": result, "logger_param": Logger, "validation": validate_result, "connection_type": connection.connection_type}\n    return local_result\nvalidate = validate\nprocess = process', globals(), core.utils.helpers.__dict__)
core.utils.helpers.result = getattr(core.utils.helpers, '__core_utils_helpers_result')
core.utils.helpers.User = getattr(core.utils.helpers, '__core_utils_helpers_User')
core.utils.helpers.Logger = getattr(core.utils.helpers, '__core_utils_helpers_Logger')
core.utils.helpers.Connection = getattr(core.utils.helpers, '__core_utils_helpers_Connection')
core.utils.helpers.connect = getattr(core.utils.helpers, '__core_utils_helpers_connect')

# ─ Module: models.user ─
import types
models = types.ModuleType('models')
models.user = types.ModuleType('models.user')
exec('process = process\n"""\\nUser model with extensive naming conflicts across the project\\n"""\nfrom typing import Dict, Any\nresult = {"model": "user"}\n__models_user_connection = None\nclass Logger:\n    """Model Logger class - conflicts with other Logger classes"""\n\n    def __init__(self, context: str):\n        self.context = context\n        self.entries = []\n        self.process = self._log_process\n\n    def _log_process(self, message: str) -> None:\n        self.entries.append(f"{self.context}: {message}")\n\n    def get_message(self) -> str:\n        return f"Model Logger: {self.context}"\n\n    def __models_user_validate(self, entry: str) -> bool:\n        """Method with name that conflicts with global functions"""\n        return len(entry) > 0\nclass __models_user_User:\n    """Model User class - major conflict with other User classes"""\n\n    def __init__(self, name: str, email: str=""):\n        self.name = name\n        self.email = email\n        self.active = True\n        self.Logger = Logger(f"user_{name}")\n        self.process = self._user_process\n        self.validate = self._user_validate\n        self.result = None\n\n    def _user_process(self, data: Any) -> str:\n        """Private method using conflicted names"""\n        util_result = util_process(data)\n        self.Logger.validate(str(data))\n        self.Logger._log_process(f"Processing: {data}")\n        self.result = f"user_model_process: {util_result}"\n        return self.result\n\n    def _user_validate(self, field: str, value: Any) -> bool:\n        """Private validation with name conflicts"""\n        if field == "name":\n            return isinstance(value, str) and len(value) > 0\n        elif field == "email":\n            return "@" in str(value) if value else True\n        return False\n\n    def authenticate(self, password: str) -> Dict[str, Any]:\n        """Method with complex internal conflicts"""\n        __models_user_validate = self.validate\n        __models_user_process = self.process\n        Logger = self.Logger\n        result = {}\n        name_valid = __models_user_validate("name", self.name)\n        email_valid = __models_user_validate("email", self.email)\n        password_valid = len(password) >= 4\n        auth_data = {"name": self.name, "email": self.email, "password_length": len(password)}\n        process_result = __models_user_process(auth_data)\n        Logger.validate(f"auth_{self.name}")\n        result = {"user": self.name, "valid": name_valid and email_valid and password_valid, "process_result": process_result, "logger_context": Logger.context}\n        return result\n\n    def __models_user_connect(self) -> str:\n        """Method with name that conflicts with global functions"""\n        global connection\n        __models_user_connection = f"user_model_connection_{self.name}"\n        return __models_user_connection\ndef process_user(data: Any) -> str:\n    """Module function with naming conflicts"""\n    global result\n    Logger = globals()["Logger"]\n    __models_user_validate = lambda x: x is not None\n    logger = Logger("process_user")\n    is_valid = __models_user_validate(data)\n    if is_valid:\n        logger._log_process(f"Processing user data: {data}")\n        processed = f"model_user_processed: {data}"\n    else:\n        processed = "model_user_invalid_data"\n    result["last_process"] = processed\n    return processed\ndef __models_user_validate(user_data: Dict[str, Any]) -> bool:\n    """Module validate function - conflicts with other validates"""\n    required_fields = ["name"]\n    return all(field in user_data for field in required_fields)\ndef __models_user_process(data: Any) -> str:\n    """Module process function - major conflict"""\n    if isinstance(data, dict):\n        return process_user(data)\n    else:\n        return f"model_process_generic: {data}"\nclass Connection:\n    """Model connection class - conflicts with other Connection classes"""\n\n    def __init__(self, User: "User"):\n        self.User = __models_user_User\n        self.connected = False\n\n    def __models_user_connect(self) -> str:\n        self.connected = True\n        return f"Model connection for user: {self.User.name}"\n\n    def __models_user_process(self, action: str) -> str:\n        """Method with conflicted name"""\n        return f"connection_process: {action} for {self.User.name}"\ndef __models_user_connect(User: "User") -> Connection:\n    """Module connect function with parameter conflicts"""\n    return Connection(__models_user_User)\ndef complex_operation(User: Any=None, Logger: Any=None, process: Any=None, validate: Any=None, result: Any=None, connection: Any=None) -> Dict[str, Any]:\n    """Function with all parameter names conflicting with globals/classes"""\n    operation_result = {"user_param": User, "logger_param": Logger, "process_param": process, "validate_param": validate, "result_param": result, "connection_param": connection}\n    __models_user_User = globals()["User"]\n    Logger = globals()["Logger"]\n    if operation_result["user_param"]:\n        user = __models_user_User("complex_user")\n        logger = Logger("complex_operation")\n        operation_result["created_user"] = user.name\n        operation_result["created_logger"] = logger.context\n    return operation_result\n__models_user_process = __models_user_process\n__models_user_validate = __models_user_validate\n__models_user_User = __models_user_User\nLogger = Logger', globals(), models.user.__dict__)
models.user.connection = getattr(models.user, '__models_user_connection')
models.user.validate = getattr(models.user, '__models_user_validate')
models.user.User = getattr(models.user, '__models_user_User')
models.user.connect = getattr(models.user, '__models_user_connect')
models.user.process = getattr(models.user, '__models_user_process')

# ─ Module: core.database.connection ─
import types
core.database = types.ModuleType('core.database')
core.database.connection = types.ModuleType('core.database.connection')
exec('process_user = process_user\nvalidate = core.database.utils.helpers.validate\n"""\\nDatabase connection module with naming conflicts\\n"""\n__core_database_connection_result = []\nconnection = None\nclass Connection:\n    """Database connection class"""\n\n    def __init__(self, host="localhost", port=5432):\n        self.host = host\n        self.port = port\n        self.connected = False\n        self.result = None\n        self.process = self._internal_process\n\n    def _internal_process(self, query):\n        return f"db_internal: {query}"\n\n    def __core_database_connection_connect(self):\n        global connection\n        self.connected = True\n        connection = self\n        return f"Connected to {self.host}:{self.port}"\ndef process(data):\n    """Database process function - conflicts with other process functions"""\n    global result\n    validated = helper_validate(data)\n    user_result = process_user(data)\n    processed = {"db_process": True, "data": validated, "user_processing": user_result, "timestamp": "2024-01-01"}\n    __core_database_connection_result.append(processed)\n    return f"db_processed: {data}"\ndef validate(data):\n    """Database validate function - another conflict"""\n    if not data:\n        return False\n    return f"db_valid: {data}"\ndef __core_database_connection_connect():\n    """Module-level connect function"""\n    global connection\n    if connection is None:\n        connection = Connection()\n    return connection.connect()\nprocess = process', globals(), core.database.connection.__dict__)
core.database.connection.result = getattr(core.database.connection, '__core_database_connection_result')
core.database.connection.connect = getattr(core.database.connection, '__core_database_connection_connect')

# ─ Module: services.auth.manager ─
import types
services = types.ModuleType('services')
services.auth = types.ModuleType('services.auth')
services.auth.manager = types.ModuleType('services.auth.manager')
exec('Connection = Connection\nbase = base\n"""\\nAuthentication manager with complex naming conflicts\\n"""\nfrom typing import Optional, Dict, Any\nresult = "auth_result"\nvalidate = lambda x: f"auth_lambda_validate: {x}"\nclass __services_auth_manager_User:\n    """Auth User class - conflicts with other User classes/variables"""\n\n    def __init__(self, username: str, password: str):\n        self.username = username\n        self.password = password\n        self.authenticated = False\n        self.result = None\n        self.connection = None\n\n    def authenticate(self) -> bool:\n        """Authenticate user with name conflicts"""\n        validate = self._internal_validate\n        result = validate(self.password)\n        self.authenticated = result\n        self.result = f"auth_user_{self.username}_{result}"\n        return result\n\n    def _internal_validate(self, password: str) -> bool:\n        return len(password) >= 4\n\n    def __services_auth_manager_connect(self) -> str:\n        """Method with same name as global functions"""\n        self.connection = DBConnection()\n        return f"User {self.username} connected"\nclass Connection:\n    """Auth connection class - conflicts with DB Connection"""\n\n    def __init__(self, auth_type: str="oauth"):\n        self.auth_type = auth_type\n        self.users = []\n\n    def add_user(self, User: "User") -> None:\n        """Add user with parameter name conflict"""\n        self.users.append(__services_auth_manager_User)\n\n    def process(self, User: str) -> str:\n        """Process with parameter name conflicts"""\n        return f"auth_connection_process: {User}"\ndef process(data: Any) -> str:\n    """Auth process function - major conflict"""\n    global result\n    base_init = base.initialize()\n    if isinstance(data, str):\n        validate = lambda x: x.startswith("auth_")\n        validated = validate(data)\n        processed = f"auth_str_{data}" if validated else f"invalid_auth_{data}"\n    else:\n        processed = f"auth_other_{data}"\n    result = f"{result}_processed"\n    return f"auth_processed: {processed}, base: {base_init}"\ndef validate(data: Any) -> str:\n    """Auth validate function - conflicts with other validate functions"""\n    if not data:\n        return "auth_invalid"\n    global_validate = globals().get("validate", lambda x: f"fallback_{x}")\n    lambda_result = global_validate(data) if callable(global_validate) else str(data)\n    return f"auth_valid: {data}, lambda: {lambda_result}"\ndef __services_auth_manager_connect(User: Optional["User"]=None) -> Connection:\n    """Connect function with parameter conflict"""\n    connection = Connection("auth_manager")\n    if __services_auth_manager_User:\n        connection.add_user(__services_auth_manager_User)\n    return connection\nclass AuthManager:\n    """Manager class with extensive conflicts"""\n\n    def __init__(self):\n        self.connections = []\n        self.users = []\n        self.process = self._manager_process\n        self.validate = self._manager_validate\n        self.User = None\n\n    def _manager_process(self, data: Any) -> str:\n        return f"manager_process: {data}"\n\n    def _manager_validate(self, data: Any) -> bool:\n        return data is not None\n\n    def add_user(self, username: str, password: str) -> "User":\n        """Method that creates User with local scope conflicts"""\n        __services_auth_manager_User = globals()["User"]\n        user = __services_auth_manager_User(username, password)\n        self.users.append(user)\n        self.User = user\n        return user\n\n    def process_all(self) -> Dict[str, Any]:\n        """Method using conflicting names throughout"""\n        result = []\n        for __services_auth_manager_User in self.users:\n            user_result = process(__services_auth_manager_User.username)\n            validate_result = validate(__services_auth_manager_User.password)\n            connection = __services_auth_manager_connect(__services_auth_manager_User)\n            connection_process = connection.process(__services_auth_manager_User.username)\n            result.append({"user": User.username, "process": user_result, "validate": validate_result, "connection": connection_process})\n        return {"manager_results": result}\nprocess = process\nvalidate = validate\n__services_auth_manager_User = __services_auth_manager_User', globals(), services.auth.manager.__dict__)
services.auth.manager.User = getattr(services.auth.manager, '__services_auth_manager_User')
services.auth.manager.connect = getattr(services.auth.manager, '__services_auth_manager_connect')

# ─ Module: models.base ─
import types
models.base = types.ModuleType('models.base')
exec('validate = validate\nLogger = Logger\n"""\\nBase model functionality with relative import conflicts\\n"""\nfrom typing import Any, Dict\nresult = "base_result"\n__models_base_process = "base_process_string"\nclass BaseModel:\n    """Base model class with method name conflicts"""\n\n    def __init__(self, model_type: str):\n        self.model_type = model_type\n        self.initialized = False\n        self.validate = self._base_validate\n        self.process = self._base_process\n        self.Logger = UserLogger("base_model")\n\n    def _base_validate(self, data: Any) -> bool:\n        """Base validation using relative imports"""\n        return core_validate(data)\n\n    def _base_process(self, data: Any) -> str:\n        """Base processing with conflicts"""\n        validated = self.validate(data)\n        if validated:\n            self.Logger._log_process(f"Base processing: {data}")\n            return f"base_processed: {data}"\n        return "base_invalid"\n\n    def initialize(self) -> str:\n        """Initialize with name conflicts"""\n        global result\n        self.initialized = True\n        result = f"base_initialized_{self.model_type}"\n        return result\ndef initialize() -> str:\n    """Module initialization function"""\n    global result\n    base = BaseModel("default")\n    init_result = base.initialize()\n    logger = UserLogger("base_init")\n    logger._log_process("Base module initialized")\n    result = f"module_init: {init_result}"\n    return result\ndef __models_base_validate(data: Any) -> bool:\n    """Base validate function - conflicts everywhere"""\n    return core_validate(data) and data != "invalid"\ndef __models_base_process(data: Any) -> str:\n    """Base process function - conflicts everywhere"""\n    global result\n    validated = __models_base_validate(data)\n    if validated:\n        processed = f"base_module_process: {data}"\n    else:\n        processed = "base_module_invalid"\n    result = f"base_last_process: {processed}"\n    return processed\nclass Logger:\n    """Base Logger class - yet another Logger conflict"""\n\n    def __init__(self, source: str):\n        self.source = source\n        self.logs = []\n\n    def log(self, message: str) -> None:\n        self.logs.append(f"[BASE {self.source}] {message}")\n\n    def __models_base_process(self, log_data: Any) -> str:\n        """Logger process method - conflicts with global process"""\n        self.log(f"Processing: {log_data}")\n        return f"base_logger_process: {log_data}"\ndef __models_base_connect() -> str:\n    """Base connect function"""\n    return "base_connected"\ndef shadow_test(validate: Any=None, process: Any=None, Logger: Any=None, result: Any=None, initialize: Any=None) -> Dict[str, Any]:\n    """Function that shadows all major conflict names with parameters"""\n    shadows = {"validate_param": validate, "process_param": process, "Logger_param": Logger, "result_param": result, "initialize_param": initialize}\n    __models_base_validate = globals()["validate"]\n    __models_base_process = globals()["process"]\n    Logger = globals()["Logger"]\n    validation_result = __models_base_validate("test_data")\n    process_result = __models_base_process("test_data")\n    logger = Logger("shadow_test")\n    shadows.update({"global_validate_result": validation_result, "global_process_result": process_result, "global_logger_source": logger.source})\n    return shadows\n__models_base_validate = __models_base_validate\n__models_base_process = __models_base_process\nLogger = Logger\ninitialize = initialize', globals(), models.base.__dict__)
models.base.process = getattr(models.base, '__models_base_process')
models.base.validate = getattr(models.base, '__models_base_validate')
models.base.connect = getattr(models.base, '__models_base_connect')

# ─ Module: core.database ─
Connection = core.database.connection.Connection
process = core.database.connection.process
Logger = core.utils.helpers.Logger
__core_database_User = "database_user_type"

# ─ Module: core.utils ─
Logger = core.utils.helpers.Logger
process = core.utils.helpers.process
validate = core.utils.helpers.validate
Connection = "utils_connection_type"

# ─ Module: services.auth ─
User = services.auth.manager.User
process = services.auth.manager.process
validate = services.auth.manager.validate
Logger = core.utils.helpers.Logger
connection = "auth_connection_string"

# ─ Module: core ─
Logger = core.utils.helpers.Logger
process = core.utils.helpers.process
result = "core_package_result"
Logger = CoreLogger

# ─ Module: models ─
exec('global User, Logger, process_user, initialize\nUser = models.user.User\nLogger = models.user.Logger\nprocess_user = models.user.process_user\ninitialize = models.base.initialize\nprocess = "models_process_string"\nvalidate = "models_validate_string"\nconnection = "models_connection_string"\nlocals()[\'User\'] = User\nlocals()[\'Logger\'] = Logger\nlocals()[\'process_user\'] = process_user\nlocals()[\'initialize\'] = initialize', {**globals(), 'models': models}, models.__dict__)

# ─ Module: services ─
User = services.auth.manager.User
process = services.auth.manager.process
Logger = "services_logger_string"
result = {"services": "initialized"}

# ─ Entry Module: main ─
db_process = core.database.connection.process
process = core.utils.helpers.process
UtilLogger = core.utils.helpers.Logger
validate = core.utils.helpers.validate
auth_process = services.auth.manager.process
User = services.auth.manager.User
auth_validate = services.auth.manager.validate
UserModel = models.user.User
process_user = models.user.process_user
Logger = models.user.Logger
base = models.base
base = base
"""\nComprehensive AST rewriter test fixture - Main entry point\nThis module demonstrates complex naming conflicts and import scenarios\n"""
result = 42
connection = None
Logger = "string_logger"
def validate(data):
    """This validate function conflicts with imported validate functions"""
    return f"main_validate: {data}"
def process():
    """This process function conflicts with multiple imported process functions"""
    return "main_process"
class __main_User:
    """This User class conflicts with imported User classes"""

    def __init__(self, name):
        self.name = name
        self.result = self._process_name(name)

    def _process_name(self, name):
        return f"main_user: {name}"
class Connection:
    """Connection class that conflicts with database connection"""

    def __init__(self):
        self.status = "disconnected"

    def connect(self):
        global connection
        connection = self
        return "main_connection_established"
def main():
    """Main function demonstrating all the conflicts in action"""
    db_result = db_process("database_data")
    util_result = process("utility_data")
    auth_result = auth_process("auth_data")
    util_logger = UtilLogger("util")
    model_logger = Logger("model")
    auth_user = __main_User("auth_type")
    model_user = UserModel("model_type")
    service_user = __main_User("service_type", "password")
    local_validate_result = validate("local_data")
    auth_validate_result = auth_validate("auth_data")
    util_validate_result = validate("util_data")
    result = db_result + util_result + auth_result
    base_result = base.initialize()
    final_result = {"process_results": [db_result, util_result, auth_result], "validation_results": [local_validate_result, auth_validate_result, util_validate_result], "user_types": [auth_user.name, model_user.name, service_user.username], "logger_messages": [util_logger.get_message(), model_logger.get_message()], "base_init": base_result, "total": result + globals()["result"]}
    return final_result
if __name__ == "__main__":
    connection = Connection()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
