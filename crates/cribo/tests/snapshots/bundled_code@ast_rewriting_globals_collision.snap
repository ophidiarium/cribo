---
source: crates/cribo/tests/test_bundling_snapshots.rs
input_file: crates/cribo/tests/fixtures/ast_rewriting_globals_collision/main.py
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

import sys as _sys
import importlib as _importlib
class _CriboModule():

    def __init__(self, m, p):
        self._m, self._p = m, p

    def __getattr__(self, n):
        f = self._p + '.' + n
        try:
            return _CriboModule(_importlib.import_module(f), f)
        except ImportError:
            return getattr(self._m, n)

    def __getattribute__(self, n):
        return object.__getattribute__(self, n) if n in ('_m', '_p', '__getattr__', '__class__', '__dict__', '__dir__', '__module__', '__qualname__') else getattr(object.__getattribute__(self, '_m'), n)
class _Cribo():

    def __getattr__(self, n):
        m = _sys.modules.get(n) or _importlib.import_module(n)
        return _CriboModule(m, n)
_cribo = _Cribo()
models_base = _cribo.types.SimpleNamespace(__name__='models.base', __initializing__=False, __initialized__=False)
_cribo_models_base_Connection = None
def _cribo_init___cribo_0a162a_models_base(self):
    if self.__initialized__:
        return self
    if self.__initializing__:
        self.__initializing__ = False
        return self
    global _cribo_models_base_Connection
    """Base models module - imports only from core to avoid circular dependencies"""
    models_base.util_validate = validate_6
    util_validate = validate_6
    process = lambda x: f"base_process: {x}"
    self.process = process
    validate = 123
    self.validate = validate
    Logger = None
    self.Logger = Logger
    Connection = []
    _cribo_models_base_Connection = Connection
    self.Connection = _cribo_models_base_Connection

    def process(data):
        """Process function in base module"""
        return f"base_process: {data} (overrides lambda)"
    self.process = process

    def validate(data):
        """Validate function that uses imported validate"""
        base_check = f"base_validate: {data}"
        util_check = util_validate(data)
        return f"{base_check} + {util_check}"
    self.validate = validate

    class Logger:
        """Base logger class"""

        def __init__(self, prefix="BASE"):
            self.prefix = prefix

        def get_message(self):
            return f"base_logger_{self.prefix}"
    Logger.__module__ = 'models.base'
    self.Logger = Logger

    def initialize():
        """Initialize base module"""
        global _cribo_models_base_Connection
        _cribo_models_base_Connection = type("Connection", (), {"type": "base_connection"})
        self.Connection = _cribo_models_base_Connection
        return "base_initialized"
    self.initialize = initialize
    self.__initialized__ = True
    self.__initializing__ = False
    return self
models_base.__init__ = _cribo_init___cribo_0a162a_models_base
models = _cribo.types.SimpleNamespace(__name__='models', __initializing__=False, __initialized__=False)
models.base = models_base
services_auth_manager = _cribo.types.SimpleNamespace(__name__='services.auth.manager', __initializing__=False, __initialized__=False)
def _cribo_init___cribo_0ecebd_services_auth_manager(self):
    if self.__initialized__:
        return self
    if self.__initializing__:
        self.__initializing__ = False
        return self
    """Authentication manager - imports from core and models only, no circular dependencies"""
    services_auth_manager.__initializing__ = True
    __cribo_init_result = _cribo_init___cribo_0ac752_core(core)
    for attr in dir(__cribo_init_result):
        if not attr.startswith('_'):
            setattr(core, attr, getattr(__cribo_init_result, attr))
    services_auth_manager.__initializing__ = True
    __cribo_init_result = _cribo_init___cribo_b7b3e3_core_database(core_database)
    for attr in dir(__cribo_init_result):
        if not attr.startswith('_'):
            setattr(core.database, attr, getattr(__cribo_init_result, attr))
    global core_database_connection
    services_auth_manager.__initializing__ = True
    core_database_connection = _cribo_init___cribo_df9c8d_core_database_connection(core_database_connection)
    DBConnection = core.database.connection.Connection
    self.DBConnection = DBConnection
    services_auth_manager.sanitize = sanitize
    services_auth_manager.__initializing__ = True
    __cribo_init_result = _cribo_init___cribo_293a98_models(models)
    for attr in dir(__cribo_init_result):
        if not attr.startswith('_'):
            setattr(models, attr, getattr(__cribo_init_result, attr))
    global models_base
    services_auth_manager.__initializing__ = True
    models_base = _cribo_init___cribo_0a162a_models_base(models_base)
    base_init = models.base.initialize
    self.base_init = base_init
    process = [1, 2, 3]
    self.process = process
    validate = None
    self.validate = validate
    User = "auth_user_string"
    self.User = User
    Logger = set()
    self.Logger = Logger
    Connection = {"auth": True}
    self.Connection = Connection

    def process(data):
        """Process function in auth module"""
        sanitized = sanitize(data)
        return f"auth_process: {sanitized}"
    self.process = process

    def validate(data):
        """Validate function in auth module"""
        if not isinstance(data, str):
            return f"auth_validate_failed: {data}"
        return f"auth_validate: {data}"
    self.validate = validate

    class User:
        """Auth user class"""

        def __init__(self, username):
            self.username = username
            self.connection = Connection

        def authenticate(self):
            return f"auth_user_{self.username}"
    User.__module__ = 'services.auth.manager'
    self.User = User

    class Connection:
        """Auth connection - overrides the global dict"""

        def __init__(self):
            self.db_conn = DBConnection("auth_db")
            self.status = "auth_connection"

        def connect(self):
            db_result = self.db_conn.connect()
            return f"auth_wrapped_{db_result}"
    Connection.__module__ = 'services.auth.manager'
    self.Connection = Connection

    class AuthManager:
        """Non-conflicting class name"""

        def __init__(self):
            self.users = {}
            self.base_initialized = base_init()

        def add_user(self, user):
            self.users[user.username] = user

        def process_auth(self, username, data):
            return process(f"{username}:{data}")
    AuthManager.__module__ = 'services.auth.manager'
    self.AuthManager = AuthManager
    self.__initialized__ = True
    self.__initializing__ = False
    return self
services_auth_manager.__init__ = _cribo_init___cribo_0ecebd_services_auth_manager
services = _cribo.types.SimpleNamespace(__name__='services', __initializing__=False, __initialized__=False)
services_auth = _cribo.types.SimpleNamespace(__name__='services.auth', __initializing__=False, __initialized__=False, __path__=[])
services.auth = services_auth
services_auth.manager = services_auth_manager
core_utils_helpers = _cribo.types.SimpleNamespace(__name__='core.utils.helpers')
core = _cribo.types.SimpleNamespace(__name__='core', __initializing__=False, __initialized__=False)
core_utils = _cribo.types.SimpleNamespace(__name__='core.utils', __initializing__=False, __initialized__=False, __path__=[])
core.utils = core_utils
core_utils.helpers = core_utils_helpers
"""Core utility helpers module - NO external dependencies to avoid circular imports"""
process_count = 0
validate_cache = {}
Logger_6 = str
Connection_6 = "not_a_class"
def process_7(data):
    """Process function in utils module"""
    global process_count
    process_count += 1
    return f"utils_process: {data} (#{process_count})"
def validate_6(data):
    """Validate function in utils module"""
    if data in validate_cache:
        return validate_cache[data]
    result = f"utils_validate: {data}"
    validate_cache[data] = result
    return result
class Logger_6:
    """Logger class in utils module"""

    def __init__(self, name):
        self.name = name
        self.messages = []

    def log(self, message):
        self.messages.append(f"[{self.name}] {message}")

    def get_message(self):
        return f"utils_logger_{self.name}"
Logger_6.__module__ = 'core.utils.helpers'
Logger_6.__name__ = 'Logger'
Logger_6.__qualname__ = 'Logger'
class Connection_6:
    """Connection class in utils - different from database Connection"""

    def __init__(self):
        self.type = "utility_connection"

    def connect(self):
        return "utils_connection_established"
Connection_6.__module__ = 'core.utils.helpers'
Connection_6.__name__ = 'Connection'
Connection_6.__qualname__ = 'Connection'
def sanitize(text):
    """Utility function without conflicts"""
    return text.strip().lower()
def format_result(result):
    """Another utility function"""
    return f"formatted: {result}"
core_utils_helpers.Connection = Connection_6
core_utils_helpers.Logger = Logger_6
core_utils_helpers.format_result = format_result
core_utils_helpers.process = process_7
core_utils_helpers.process_count = process_count
core_utils_helpers.sanitize = sanitize
core_utils_helpers.validate = validate_6
core_utils_helpers.validate_cache = validate_cache
core_database_connection = _cribo.types.SimpleNamespace(__name__='core.database.connection', __initializing__=False, __initialized__=False)
def _cribo_init___cribo_df9c8d_core_database_connection(self):
    if self.__initialized__:
        return self
    if self.__initializing__:
        self.__initializing__ = False
        return self
    """Database connection module - imports only from core.utils to avoid circular dependencies"""
    process = None
    self.process = process
    validate = lambda x: f"db_validate: {x}"
    self.validate = validate
    User = {"type": "database_user"}
    self.User = User

    def process(data):
        """Process function in database module"""
        core_database_connection.sanitize = sanitize
        core_database_connection.format_result = format_result
        clean_data = sanitize(data)
        return f"db_process: {clean_data}"
    self.process = process

    def validate(data):
        """Validate function in database module"""
        core_database_connection.sanitize = sanitize
        core_database_connection.format_result = format_result
        return f"db_validate: {data} (overrides lambda)"
    self.validate = validate

    class Connection:
        """Database connection class"""

        def __init__(self, db_name="default"):
            self.db_name = db_name
            self.connected = False

        def connect(self):
            self.connected = True
            return f"db_connection_to_{self.db_name}"

        def execute(self, query):
            if not self.connected:
                raise RuntimeError("Not connected")
            return format_result(f"Query: {query}")
    Connection.__module__ = 'core.database.connection'
    self.Connection = Connection

    class Logger:
        """Database logger - different from utils Logger"""

        def __init__(self, context):
            self.context = context

        def log(self, message):
            return f"DB_LOG[{self.context}]: {message}"
    Logger.__module__ = 'core.database.connection'
    self.Logger = Logger

    def create_connection(db_name):
        """Factory function"""
        core_database_connection.sanitize = sanitize
        core_database_connection.format_result = format_result
        conn = Connection(db_name)
        conn.connect()
        return conn
    self.create_connection = create_connection
    self.__initialized__ = True
    self.__initializing__ = False
    return self
core_database_connection.__init__ = _cribo_init___cribo_df9c8d_core_database_connection
core_database = _cribo.types.SimpleNamespace(__name__='core.database', __initializing__=False, __initialized__=False, __path__=[])
core.database = core_database
core_database.connection = core_database_connection
def _cribo_init___cribo_b7b3e3_core_database(self):
    if self.__initialized__:
        return self
    if self.__initializing__:
        self.__initializing__ = False
        return self
    validate = "db_package_validate"
    self.validate = validate
    self.__initialized__ = True
    self.__initializing__ = False
    return self
core_database.__init__ = _cribo_init___cribo_b7b3e3_core_database
def _cribo_init___cribo_0ac752_core(self):
    if self.__initialized__:
        return self
    if self.__initializing__:
        self.__initializing__ = False
        return self
    Logger = "core_logger_string"
    self.Logger = Logger
    self.__initialized__ = True
    self.__initializing__ = False
    return self
core.__init__ = _cribo_init___cribo_0ac752_core
def _cribo_init___cribo_e52b1d_core_utils(self):
    if self.__initialized__:
        return self
    if self.__initializing__:
        self.__initializing__ = False
        return self
    User = "utils_user_string"
    self.User = User
    self.helpers = core_utils_helpers
    self.helpers = core_utils_helpers
    self.__initialized__ = True
    self.__initializing__ = False
    return self
core_utils.__init__ = _cribo_init___cribo_e52b1d_core_utils
models_user = _cribo.types.SimpleNamespace(__name__='models.user', __initializing__=False, __initialized__=False)
def _cribo_init___cribo_1f9e6c_models_user(self):
    if self.__initialized__:
        return self
    if self.__initializing__:
        self.__initializing__ = False
        return self
    """User models module - imports from core and base, no circular dependencies"""
    models_user.util_process = process_7
    util_process = process_7
    models_user.UtilLogger = Logger_6
    UtilLogger = Logger_6
    models_user.__initializing__ = True
    __cribo_init_result = _cribo_init___cribo_293a98_models(models)
    for attr in dir(__cribo_init_result):
        if not attr.startswith('_'):
            setattr(models, attr, getattr(__cribo_init_result, attr))
    global models_base
    models_user.__initializing__ = True
    models_base = _cribo_init___cribo_0a162a_models_base(models_base)
    BaseLogger = models.base.Logger
    self.BaseLogger = BaseLogger
    process = "process_string"
    self.process = process
    validate = {"action": "validate"}
    self.validate = validate
    User = None
    self.User = User
    Connection = type("Connection", (), {"source": "models.user"})
    self.Connection = Connection

    def process(data):
        """Process function in user module"""
        return f"user_process: {data}"
    self.process = process

    def process_user(user_data):
        """Process user-specific data"""
        util_result = util_process(user_data)
        return f"process_user: {user_data} -> {util_result}"
    self.process_user = process_user

    def validate(data):
        """Validate function in user module"""
        return f"user_validate: {data}"
    self.validate = validate

    class User:
        """User model class"""

        def __init__(self, name):
            self.name = name
            self.logger = Logger("user")

        def process(self):
            return f"User.process: {self.name}"
    User.__module__ = 'models.user'
    self.User = User

    class Logger:
        """User module logger - different from utils and base Logger"""

        def __init__(self, context):
            self.context = context
            self.base_logger = BaseLogger(context)
            self.util_logger = UtilLogger(context)

        def get_message(self):
            return f"user_logger_{self.context}"

        def log_all(self):
            return [self.get_message(), self.base_logger.get_message(), self.util_logger.get_message()]
    Logger.__module__ = 'models.user'
    self.Logger = Logger

    class UserValidator:
        """Non-conflicting class name"""

        def __init__(self):
            self.rules = []

        def add_rule(self, rule):
            self.rules.append(rule)
    UserValidator.__module__ = 'models.user'
    self.UserValidator = UserValidator
    self.__initialized__ = True
    self.__initializing__ = False
    return self
models_user.__init__ = _cribo_init___cribo_1f9e6c_models_user
models.user = models_user
def _cribo_init___cribo_293a98_models(self):
    if self.__initialized__:
        return self
    if self.__initializing__:
        self.__initializing__ = False
        return self
    Logger = lambda x: f"models_logger_{x}"
    self.Logger = Logger
    process = "models_process"
    self.process = process
    self.__initialized__ = True
    self.__initializing__ = False
    return self
models.__init__ = _cribo_init___cribo_293a98_models
def _cribo_init___cribo_b2dda7_services(self):
    if self.__initialized__:
        return self
    if self.__initializing__:
        self.__initializing__ = False
        return self
    process = lambda x, y: f"services_process: {x}, {y}"
    self.process = process
    validate = "services_validate"
    self.validate = validate
    self.__initialized__ = True
    self.__initializing__ = False
    return self
services.__init__ = _cribo_init___cribo_b2dda7_services
def _cribo_init___cribo_84bf42_services_auth(self):
    if self.__initialized__:
        return self
    if self.__initializing__:
        self.__initializing__ = False
        return self
    Connection = lambda: "auth_package_connection"
    self.Connection = Connection
    Logger = 42
    self.Logger = Logger
    self.__initialized__ = True
    self.__initializing__ = False
    return self
services_auth.__init__ = _cribo_init___cribo_84bf42_services_auth
"""\nComprehensive AST rewriter test fixture - Main entry point\nThis module demonstrates complex naming conflicts and import scenarios\nWITHOUT circular dependencies\n"""
__cribo_init_result = _cribo_init___cribo_0ac752_core(core)
for attr in dir(__cribo_init_result):
    if not attr.startswith('_'):
        setattr(core, attr, getattr(__cribo_init_result, attr))
__cribo_init_result = _cribo_init___cribo_b7b3e3_core_database(core_database)
for attr in dir(__cribo_init_result):
    if not attr.startswith('_'):
        setattr(core.database, attr, getattr(__cribo_init_result, attr))
core_database_connection = _cribo_init___cribo_df9c8d_core_database_connection(core_database_connection)
db_process = core.database.connection.process
UtilLogger = Logger_6
__cribo_init_result = _cribo_init___cribo_b2dda7_services(services)
for attr in dir(__cribo_init_result):
    if not attr.startswith('_'):
        setattr(services, attr, getattr(__cribo_init_result, attr))
__cribo_init_result = _cribo_init___cribo_84bf42_services_auth(services_auth)
for attr in dir(__cribo_init_result):
    if not attr.startswith('_'):
        setattr(services.auth, attr, getattr(__cribo_init_result, attr))
services_auth_manager = _cribo_init___cribo_0ecebd_services_auth_manager(services_auth_manager)
auth_process = services.auth.manager.process
auth_validate = services.auth.manager.validate
__cribo_init_result = _cribo_init___cribo_293a98_models(models)
for attr in dir(__cribo_init_result):
    if not attr.startswith('_'):
        setattr(models, attr, getattr(__cribo_init_result, attr))
models_user = _cribo_init___cribo_1f9e6c_models_user(models_user)
UserModel = models.user.User
process_user = models.user.process_user
Logger = models.user.Logger
models.base = _cribo_init___cribo_0a162a_models_base(models_base)
__cribo_init_result = _cribo_init___cribo_293a98_models(models)
for attr in dir(__cribo_init_result):
    if not attr.startswith('_'):
        setattr(models, attr, getattr(__cribo_init_result, attr))
base = models.base
result = 42
connection = None
def validate_1(data):
    """This validate function conflicts with imported validate functions"""
    return f"main_validate: {data}"
validate = validate_1
def process_1(data):
    """This process function conflicts with multiple imported process functions"""
    return f"main_process: {data}"
process = process_1
class User_1:
    """This User class conflicts with imported User classes"""

    def __init__(self, name):
        self.name = name
        self.result = self._process_name(name)

    def _process_name(self, name):
        return f"main_user: {name}"
User = User_1
class Connection_1:
    """Connection class that conflicts with database connection"""

    def __init__(self):
        self.status = "disconnected"

    def connect(self):
        global connection
        connection = self
        return "main_connection_established"
Connection = Connection_1
def main():
    """Main function demonstrating all the conflicts in action"""
    db_result = db_process("database_data")
    util_result = process("utility_data")
    auth_result = auth_process("auth_data")
    util_logger = UtilLogger("util")
    model_logger = Logger("model")
    auth_user = User("auth_type")
    model_user = UserModel("model_type")
    service_user = User("service_type")
    local_validate_result = validate("local_data")
    auth_validate_result = auth_validate("auth_data")
    util_validate_result = validate("util_data")
    result = db_result + util_result + auth_result
    base_result = base.initialize()
    final_result = {"process_results": [db_result, util_result, auth_result], "validation_results": [local_validate_result, auth_validate_result, util_validate_result], "user_types": [auth_user.name, model_user.name, service_user.name], "logger_messages": [util_logger.get_message(), model_logger.get_message()], "base_init": base_result, "total": result + str(globals()["result"])}
    return final_result
if __name__ == "__main__":
    connection = Connection_1()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
