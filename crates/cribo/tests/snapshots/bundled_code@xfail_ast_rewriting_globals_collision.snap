---
source: crates/cribo/tests/test_bundling_snapshots.rs
input_file: crates/cribo/tests/fixtures/xfail_ast_rewriting_globals_collision/main.py
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

import types
class Connection_core_database_connection:
    """Database connection class"""

    def __init__(self, db_name="default"):
        self.db_name = db_name
        self.connected = False

    def connect(self):
        self.connected = True
        return f"db_connection_to_{self.db_name}"

    def execute(self, query):
        if not self.connected:
            raise RuntimeError("Not connected")
        return format_result(f"Query: {query}")
process_core_database_connection = None
class Logger_core_database_connection:
    """Database logger - different from utils Logger"""

    def __init__(self, context):
        self.context = context

    def log(self, message):
        return f"DB_LOG[{self.context}]: {message}"
class Connection_core_database_connection:
    """Database connection class"""

    def __init__(self, db_name="default"):
        self.db_name = db_name
        self.connected = False

    def connect(self):
        self.connected = True
        return f"db_connection_to_{self.db_name}"

    def execute(self, query):
        if not self.connected:
            raise RuntimeError("Not connected")
        return format_result(f"Query: {query}")
core_database_connection = types.SimpleNamespace()
core_database_connection.Connection = Connection_core_database_connection
core_database_connection.process = process_core_database_connection
core_database_connection.Logger = Logger_core_database_connection
def validate_models_user(data):
    """Validate function in user module"""
    return f"user_validate: {data}"
process_models_user = "process_string"
User_models_user = None
models_user = types.SimpleNamespace()
models_user.validate = validate_models_user
models_user.process = process_models_user
models_user.User = User_models_user
validate_models_base = 123
def process_models_base(data):
    """Process function in base module"""
    return f"base_process: {data} (overrides lambda)"
process_models_base = lambda x: f"base_process: {x}"
Connection_models_base = []
def initialize_models_base():
    """Initialize base module"""
    global Connection
    Connection = type("Connection", (), {"type": "base_connection"})
    return "base_initialized"
class Logger_models_base:
    """Base logger class"""

    def __init__(self, prefix="BASE"):
        self.prefix = prefix

    def get_message(self):
        return f"base_logger_{self.prefix}"
models_base = types.SimpleNamespace()
models_base.validate = validate_models_base
models_base.process = process_models_base
models_base.process = process_models_base
models_base.Connection = Connection_models_base
models_base.initialize = initialize_models_base
models_base.Logger = Logger_models_base
def validate_services_auth_manager(data):
    """Validate function in auth module"""
    if not isinstance(data, str):
        return f"auth_validate_failed: {data}"
    return f"auth_validate: {data}"
Logger_services_auth_manager = set()
def validate_services_auth_manager(data):
    """Validate function in auth module"""
    if not isinstance(data, str):
        return f"auth_validate_failed: {data}"
    return f"auth_validate: {data}"
def process_services_auth_manager(data):
    """Process function in auth module"""
    sanitized = sanitize(data)
    return f"auth_process: {sanitized}"
validate_services_auth_manager = None
class Connection_services_auth_manager:
    """Auth connection - overrides the global dict"""

    def __init__(self):
        self.db_conn = DBConnection("auth_db")
        self.status = "auth_connection"

    def connect(self):
        db_result = self.db_conn.connect()
        return f"auth_wrapped_{db_result}"
services_auth_manager = types.SimpleNamespace()
services_auth_manager.Logger = Logger_services_auth_manager
services_auth_manager.validate = validate_services_auth_manager
services_auth_manager.process = process_services_auth_manager
services_auth_manager.validate = validate_services_auth_manager
services_auth_manager.Connection = Connection_services_auth_manager
validate_cache = {}
def process_core_utils_helpers(data):
    """Process function in utils module"""
    global process_count
    process_count += 1
    return f"utils_process: {data} (#{process_count})"
class Logger_core_utils_helpers:
    """Logger class in utils module"""

    def __init__(self, name):
        self.name = name
        self.messages = []

    def log(self, message):
        self.messages.append(f"[{self.name}] {message}")

    def get_message(self):
        return f"utils_logger_{self.name}"
Connection_core_utils_helpers = "not_a_class"
core_utils_helpers = types.SimpleNamespace()
core_utils_helpers.validate_cache = validate_cache
core_utils_helpers.process = process_core_utils_helpers
core_utils_helpers.Logger = Logger_core_utils_helpers
core_utils_helpers.Connection = Connection_core_utils_helpers
auth_process = services_auth_manager.process
User = services_auth_manager.User
auth_validate = services_auth_manager.validate
process = core_utils_helpers.process
UtilLogger = core_utils_helpers.Logger
validate = core_utils_helpers.validate
base = models_base.base
db_process = core_database_connection.process
UserModel = models_user.User
process_user = models_user.process_user
Logger = models_user.Logger
"""\nComprehensive AST rewriter test fixture - Main entry point\nThis module demonstrates complex naming conflicts and import scenarios\nWITHOUT circular dependencies\n"""
result = 42
connection = None
def validate(data):
    """This validate function conflicts with imported validate functions"""
    return f"main_validate: {data}"
def process(data):
    """This process function conflicts with multiple imported process functions"""
    return f"main_process: {data}"
class User:
    """This User class conflicts with imported User classes"""

    def __init__(self, name):
        self.name = name
        self.result = self._process_name(name)

    def _process_name(self, name):
        return f"main_user: {name}"
class User:
    """This User class conflicts with imported User classes"""

    def __init__(self, name):
        self.name = name
        self.result = self._process_name(name)

    def _process_name(self, name):
        return f"main_user: {name}"
class User:
    """This User class conflicts with imported User classes"""

    def __init__(self, name):
        self.name = name
        self.result = self._process_name(name)

    def _process_name(self, name):
        return f"main_user: {name}"
class User:
    """This User class conflicts with imported User classes"""

    def __init__(self, name):
        self.name = name
        self.result = self._process_name(name)

    def _process_name(self, name):
        return f"main_user: {name}"
class Connection:
    """Connection class that conflicts with database connection"""

    def __init__(self):
        self.status = "disconnected"

    def connect(self):
        global connection
        connection = self
        return "main_connection_established"
class Connection:
    """Connection class that conflicts with database connection"""

    def __init__(self):
        self.status = "disconnected"

    def connect(self):
        global connection
        connection = self
        return "main_connection_established"
class Connection:
    """Connection class that conflicts with database connection"""

    def __init__(self):
        self.status = "disconnected"

    def connect(self):
        global connection
        connection = self
        return "main_connection_established"
class Connection:
    """Connection class that conflicts with database connection"""

    def __init__(self):
        self.status = "disconnected"

    def connect(self):
        global connection
        connection = self
        return "main_connection_established"
def main():
    """Main function demonstrating all the conflicts in action"""
    db_result = db_process("database_data")
    util_result = process("utility_data")
    auth_result = auth_process("auth_data")
    util_logger = UtilLogger("util")
    model_logger = Logger("model")
    auth_user = User("auth_type")
    model_user = UserModel("model_type")
    service_user = User("service_type")
    local_validate_result = validate("local_data")
    auth_validate_result = auth_validate("auth_data")
    util_validate_result = validate("util_data")
    result = db_result + util_result + auth_result
    base_result = base.initialize()
    final_result = {"process_results": [db_result, util_result, auth_result], "validation_results": [local_validate_result, auth_validate_result, util_validate_result], "user_types": [auth_user.name, model_user.name, service_user.name], "logger_messages": [util_logger.get_message(), model_logger.get_message()], "base_init": base_result, "total": result + str(globals()["result"])}
    return final_result
if __name__ == "__main__":
    connection = Connection()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
if __name__ == "__main__":
    connection = Connection()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
if __name__ == "__main__":
    connection = Connection()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
if __name__ == "__main__":
    connection = Connection()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
if __name__ == "__main__":
    connection = Connection()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
if __name__ == "__main__":
    connection = Connection()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
