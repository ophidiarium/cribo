---
source: crates/cribo/tests/test_bundling_snapshots.rs
input_file: crates/cribo/tests/fixtures/xfail_ast_rewriting_globals_collision/main.py
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

from types import SimpleNamespace
base = SimpleNamespace()
"""\nComprehensive AST rewriter test fixture - Main entry point\nThis module demonstrates complex naming conflicts and import scenarios\nWITHOUT circular dependencies\n"""
"""User models module - imports from core and base, no circular dependencies"""
"""Database connection module - imports only from core.utils to avoid circular dependencies"""
"""Authentication manager - imports from core and models only, no circular dependencies"""
"""Base models module - imports only from core to avoid circular dependencies"""
"""Core utility helpers module - NO external dependencies to avoid circular imports"""
User_core_utils = "utils_user_string"
validate_core_database = "db_package_validate"
process_services = lambda x, y: f"services_process: {x}, {y}"
process_count = 0
Connection_services_auth = lambda: "auth_package_connection"
process_core_database_connection = None
Logger_core = "core_logger_string"
Logger_models = lambda x: f"models_logger_{x}"
validate_services = "services_validate"
process_models_base = lambda x: f"base_process: {x}"
validate_cache = {}
Logger_services_auth = 42
process_models_user = "process_string"
validate_core_database_connection = lambda x: f"db_validate: {x}"
process_models = "models_process"
validate_models_base = 123
Logger_core_utils_helpers = str
validate_models_user = {"action": "validate"}
User_core_database_connection = {"type": "database_user"}
process_services_auth_manager = [1, 2, 3]
Logger_models_base = None
Connection_core_utils_helpers = "not_a_class"
User_models_user = None
def process_core_database_connection(data):
    """Process function in database module"""
    clean_data = sanitize(data)
    return f"db_process: {clean_data}"
validate_services_auth_manager = None
Connection_models_base = []
def process_core_utils_helpers(data):
    """Process function in utils module"""
    global process_count
    process_count += 1
    return f"utils_process: {data} (#{process_count})"
result = 42
Connection_models_user = type("Connection", (), {"source": "models.user"})
def validate_core_database_connection(data):
    """Validate function in database module"""
    return f"db_validate: {data} (overrides lambda)"
User_services_auth_manager = "auth_user_string"
def process_models_base(data):
    """Process function in base module"""
    return f"base_process: {data} (overrides lambda)"
def validate_core_utils_helpers(data):
    """Validate function in utils module"""
    if data in validate_cache:
        return validate_cache[data]
    result = f"utils_validate: {data}"
    validate_cache[data] = result
    return result
connection = None
def process_models_user(data):
    """Process function in user module"""
    return f"user_process: {data}"
class Connection_core_database_connection:
    """Database connection class"""

    def __init__(self, db_name="default"):
        self.db_name = db_name
        self.connected = False

    def connect(self):
        self.connected = True
        return f"db_connection_to_{self.db_name}"

    def execute(self, query):
        if not self.connected:
            raise RuntimeError("Not connected")
        return format_result(f"Query: {query}")
Logger_services_auth_manager = set()
def validate_models_base(data):
    """Validate function that uses imported validate"""
    base_check = f"base_validate: {data}"
    util_check = util_validate(data)
    return f"{base_check} + {util_check}"
def validate_core_utils_helpers(data):
    """Validate function in utils module"""
    if data in validate_cache:
        return validate_cache[data]
    result = f"utils_validate: {data}"
    validate_cache[data] = result
    return result
def validate(data):
    """This validate function conflicts with imported validate functions"""
    return f"main_validate: {data}"
def process_user_models_user(user_data):
    """Process user-specific data"""
    util_result = util_process(user_data)
    return f"process_user: {user_data} -> {util_result}"
class Connection_core_database_connection:
    """Database connection class"""

    def __init__(self, db_name="default"):
        self.db_name = db_name
        self.connected = False

    def connect(self):
        self.connected = True
        return f"db_connection_to_{self.db_name}"

    def execute(self, query):
        if not self.connected:
            raise RuntimeError("Not connected")
        return format_result(f"Query: {query}")
Connection_services_auth_manager = {"auth": True}
class Logger_models_base:
    """Base logger class"""

    def __init__(self, prefix="BASE"):
        self.prefix = prefix

    def get_message(self):
        return f"base_logger_{self.prefix}"
class Logger_core_utils_helpers:
    """Logger class in utils module"""

    def __init__(self, name):
        self.name = name
        self.messages = []

    def log(self, message):
        self.messages.append(f"[{self.name}] {message}")

    def get_message(self):
        return f"utils_logger_{self.name}"
def process(data):
    """This process function conflicts with multiple imported process functions"""
    return f"main_process: {data}"
def validate_models_user(data):
    """Validate function in user module"""
    return f"user_validate: {data}"
class Connection_core_database_connection:
    """Database connection class"""

    def __init__(self, db_name="default"):
        self.db_name = db_name
        self.connected = False

    def connect(self):
        self.connected = True
        return f"db_connection_to_{self.db_name}"

    def execute(self, query):
        if not self.connected:
            raise RuntimeError("Not connected")
        return format_result(f"Query: {query}")
def process_services_auth_manager(data):
    """Process function in auth module"""
    sanitized = sanitize(data)
    return f"auth_process: {sanitized}"
class Logger_models_base:
    """Base logger class"""

    def __init__(self, prefix="BASE"):
        self.prefix = prefix

    def get_message(self):
        return f"base_logger_{self.prefix}"
class Logger_core_utils_helpers:
    """Logger class in utils module"""

    def __init__(self, name):
        self.name = name
        self.messages = []

    def log(self, message):
        self.messages.append(f"[{self.name}] {message}")

    def get_message(self):
        return f"utils_logger_{self.name}"
class User:
    """This User class conflicts with imported User classes"""

    def __init__(self, name):
        self.name = name
        self.result = self._process_name(name)

    def _process_name(self, name):
        return f"main_user: {name}"
class User_models_user:
    """User model class"""

    def __init__(self, name):
        self.name = name
        self.logger = Logger("user")

    def process(self):
        return f"User.process: {self.name}"
class Connection_core_database_connection:
    """Database connection class"""

    def __init__(self, db_name="default"):
        self.db_name = db_name
        self.connected = False

    def connect(self):
        self.connected = True
        return f"db_connection_to_{self.db_name}"

    def execute(self, query):
        if not self.connected:
            raise RuntimeError("Not connected")
        return format_result(f"Query: {query}")
def validate_services_auth_manager(data):
    """Validate function in auth module"""
    if not isinstance(data, str):
        return f"auth_validate_failed: {data}"
    return f"auth_validate: {data}"
class Logger_models_base:
    """Base logger class"""

    def __init__(self, prefix="BASE"):
        self.prefix = prefix

    def get_message(self):
        return f"base_logger_{self.prefix}"
class Logger_core_utils_helpers:
    """Logger class in utils module"""

    def __init__(self, name):
        self.name = name
        self.messages = []

    def log(self, message):
        self.messages.append(f"[{self.name}] {message}")

    def get_message(self):
        return f"utils_logger_{self.name}"
class User:
    """This User class conflicts with imported User classes"""

    def __init__(self, name):
        self.name = name
        self.result = self._process_name(name)

    def _process_name(self, name):
        return f"main_user: {name}"
class User_models_user:
    """User model class"""

    def __init__(self, name):
        self.name = name
        self.logger = Logger("user")

    def process(self):
        return f"User.process: {self.name}"
class Connection_core_database_connection:
    """Database connection class"""

    def __init__(self, db_name="default"):
        self.db_name = db_name
        self.connected = False

    def connect(self):
        self.connected = True
        return f"db_connection_to_{self.db_name}"

    def execute(self, query):
        if not self.connected:
            raise RuntimeError("Not connected")
        return format_result(f"Query: {query}")
def validate_services_auth_manager(data):
    """Validate function in auth module"""
    if not isinstance(data, str):
        return f"auth_validate_failed: {data}"
    return f"auth_validate: {data}"
class Logger_models_base:
    """Base logger class"""

    def __init__(self, prefix="BASE"):
        self.prefix = prefix

    def get_message(self):
        return f"base_logger_{self.prefix}"
class Logger_core_utils_helpers:
    """Logger class in utils module"""

    def __init__(self, name):
        self.name = name
        self.messages = []

    def log(self, message):
        self.messages.append(f"[{self.name}] {message}")

    def get_message(self):
        return f"utils_logger_{self.name}"
class User:
    """This User class conflicts with imported User classes"""

    def __init__(self, name):
        self.name = name
        self.result = self._process_name(name)

    def _process_name(self, name):
        return f"main_user: {name}"
class User_models_user:
    """User model class"""

    def __init__(self, name):
        self.name = name
        self.logger = Logger("user")

    def process(self):
        return f"User.process: {self.name}"
class Connection_core_database_connection:
    """Database connection class"""

    def __init__(self, db_name="default"):
        self.db_name = db_name
        self.connected = False

    def connect(self):
        self.connected = True
        return f"db_connection_to_{self.db_name}"

    def execute(self, query):
        if not self.connected:
            raise RuntimeError("Not connected")
        return format_result(f"Query: {query}")
class User_services_auth_manager:
    """Auth user class"""

    def __init__(self, username):
        self.username = username
        self.connection = Connection

    def authenticate(self):
        return f"auth_user_{self.username}"
def initialize_models_base():
    """Initialize base module"""
    global Connection
    Connection = type("Connection", (), {"type": "base_connection"})
    return "base_initialized"
class Logger_core_utils_helpers:
    """Logger class in utils module"""

    def __init__(self, name):
        self.name = name
        self.messages = []

    def log(self, message):
        self.messages.append(f"[{self.name}] {message}")

    def get_message(self):
        return f"utils_logger_{self.name}"
class User:
    """This User class conflicts with imported User classes"""

    def __init__(self, name):
        self.name = name
        self.result = self._process_name(name)

    def _process_name(self, name):
        return f"main_user: {name}"
class User_models_user:
    """User model class"""

    def __init__(self, name):
        self.name = name
        self.logger = Logger("user")

    def process(self):
        return f"User.process: {self.name}"
class Logger_core_database_connection:
    """Database logger - different from utils Logger"""

    def __init__(self, context):
        self.context = context

    def log(self, message):
        return f"DB_LOG[{self.context}]: {message}"
class User_services_auth_manager:
    """Auth user class"""

    def __init__(self, username):
        self.username = username
        self.connection = Connection

    def authenticate(self):
        return f"auth_user_{self.username}"
class Connection_core_utils_helpers:
    """Connection class in utils - different from database Connection"""

    def __init__(self):
        self.type = "utility_connection"

    def connect(self):
        return "utils_connection_established"
class Connection:
    """Connection class that conflicts with database connection"""

    def __init__(self):
        self.status = "disconnected"

    def connect(self):
        global connection
        connection = self
        return "main_connection_established"
class Logger_models_user:
    """User module logger - different from utils and base Logger"""

    def __init__(self, context):
        self.context = context
        self.base_logger = BaseLogger(context)
        self.util_logger = UtilLogger(context)

    def get_message(self):
        return f"user_logger_{self.context}"

    def log_all(self):
        return [self.get_message(), self.base_logger.get_message(), self.util_logger.get_message()]
class Logger_core_database_connection:
    """Database logger - different from utils Logger"""

    def __init__(self, context):
        self.context = context

    def log(self, message):
        return f"DB_LOG[{self.context}]: {message}"
class User_services_auth_manager:
    """Auth user class"""

    def __init__(self, username):
        self.username = username
        self.connection = Connection

    def authenticate(self):
        return f"auth_user_{self.username}"
class Connection_core_utils_helpers:
    """Connection class in utils - different from database Connection"""

    def __init__(self):
        self.type = "utility_connection"

    def connect(self):
        return "utils_connection_established"
class Connection:
    """Connection class that conflicts with database connection"""

    def __init__(self):
        self.status = "disconnected"

    def connect(self):
        global connection
        connection = self
        return "main_connection_established"
class Logger_models_user:
    """User module logger - different from utils and base Logger"""

    def __init__(self, context):
        self.context = context
        self.base_logger = BaseLogger(context)
        self.util_logger = UtilLogger(context)

    def get_message(self):
        return f"user_logger_{self.context}"

    def log_all(self):
        return [self.get_message(), self.base_logger.get_message(), self.util_logger.get_message()]
class Logger_core_database_connection:
    """Database logger - different from utils Logger"""

    def __init__(self, context):
        self.context = context

    def log(self, message):
        return f"DB_LOG[{self.context}]: {message}"
class User_services_auth_manager:
    """Auth user class"""

    def __init__(self, username):
        self.username = username
        self.connection = Connection

    def authenticate(self):
        return f"auth_user_{self.username}"
class Connection_core_utils_helpers:
    """Connection class in utils - different from database Connection"""

    def __init__(self):
        self.type = "utility_connection"

    def connect(self):
        return "utils_connection_established"
class Connection:
    """Connection class that conflicts with database connection"""

    def __init__(self):
        self.status = "disconnected"

    def connect(self):
        global connection
        connection = self
        return "main_connection_established"
class Logger_models_user:
    """User module logger - different from utils and base Logger"""

    def __init__(self, context):
        self.context = context
        self.base_logger = BaseLogger(context)
        self.util_logger = UtilLogger(context)

    def get_message(self):
        return f"user_logger_{self.context}"

    def log_all(self):
        return [self.get_message(), self.base_logger.get_message(), self.util_logger.get_message()]
class Logger_core_database_connection:
    """Database logger - different from utils Logger"""

    def __init__(self, context):
        self.context = context

    def log(self, message):
        return f"DB_LOG[{self.context}]: {message}"
class Connection_services_auth_manager:
    """Auth connection - overrides the global dict"""

    def __init__(self):
        self.db_conn = DBConnection("auth_db")
        self.status = "auth_connection"

    def connect(self):
        db_result = self.db_conn.connect()
        return f"auth_wrapped_{db_result}"
class Connection_core_utils_helpers:
    """Connection class in utils - different from database Connection"""

    def __init__(self):
        self.type = "utility_connection"

    def connect(self):
        return "utils_connection_established"
class Connection:
    """Connection class that conflicts with database connection"""

    def __init__(self):
        self.status = "disconnected"

    def connect(self):
        global connection
        connection = self
        return "main_connection_established"
class Logger_models_user:
    """User module logger - different from utils and base Logger"""

    def __init__(self, context):
        self.context = context
        self.base_logger = BaseLogger(context)
        self.util_logger = UtilLogger(context)

    def get_message(self):
        return f"user_logger_{self.context}"

    def log_all(self):
        return [self.get_message(), self.base_logger.get_message(), self.util_logger.get_message()]
def create_connection(db_name):
    """Factory function"""
    conn = Connection(db_name)
    conn.connect()
    return conn
class Connection_services_auth_manager:
    """Auth connection - overrides the global dict"""

    def __init__(self):
        self.db_conn = DBConnection("auth_db")
        self.status = "auth_connection"

    def connect(self):
        db_result = self.db_conn.connect()
        return f"auth_wrapped_{db_result}"
def sanitize_core_utils_helpers(text):
    """Utility function without conflicts"""
    return text.strip().lower()
def main():
    """Main function demonstrating all the conflicts in action"""
    db_result = db_process("database_data")
    util_result = process("utility_data")
    auth_result = auth_process("auth_data")
    util_logger = UtilLogger("util")
    model_logger = Logger("model")
    auth_user = User("auth_type")
    model_user = UserModel("model_type")
    service_user = User("service_type")
    local_validate_result = validate("local_data")
    auth_validate_result = auth_validate("auth_data")
    util_validate_result = validate("util_data")
    result = db_result + util_result + auth_result
    base_result = base.initialize()
    final_result = {"process_results": [db_result, util_result, auth_result], "validation_results": [local_validate_result, auth_validate_result, util_validate_result], "user_types": [auth_user.name, model_user.name, service_user.name], "logger_messages": [util_logger.get_message(), model_logger.get_message()], "base_init": base_result, "total": result + str(globals()["result"])}
    return final_result
class Logger_models_user:
    """User module logger - different from utils and base Logger"""

    def __init__(self, context):
        self.context = context
        self.base_logger = BaseLogger(context)
        self.util_logger = UtilLogger(context)

    def get_message(self):
        return f"user_logger_{self.context}"

    def log_all(self):
        return [self.get_message(), self.base_logger.get_message(), self.util_logger.get_message()]
class Connection_services_auth_manager:
    """Auth connection - overrides the global dict"""

    def __init__(self):
        self.db_conn = DBConnection("auth_db")
        self.status = "auth_connection"

    def connect(self):
        db_result = self.db_conn.connect()
        return f"auth_wrapped_{db_result}"
def format_result_core_utils_helpers(result):
    """Another utility function"""
    return f"formatted: {result}"
if __name__ == "__main__":
    connection = Connection()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
class UserValidator:
    """Non-conflicting class name"""

    def __init__(self):
        self.rules = []

    def add_rule(self, rule):
        self.rules.append(rule)
class Connection_services_auth_manager:
    """Auth connection - overrides the global dict"""

    def __init__(self):
        self.db_conn = DBConnection("auth_db")
        self.status = "auth_connection"

    def connect(self):
        db_result = self.db_conn.connect()
        return f"auth_wrapped_{db_result}"
if __name__ == "__main__":
    connection = Connection()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
class UserValidator:
    """Non-conflicting class name"""

    def __init__(self):
        self.rules = []

    def add_rule(self, rule):
        self.rules.append(rule)
class AuthManager:
    """Non-conflicting class name"""

    def __init__(self):
        self.users = {}
        self.base_initialized = base_init()

    def add_user(self, user):
        self.users[user.username] = user

    def process_auth(self, username, data):
        return process(f"{username}:{data}")
if __name__ == "__main__":
    connection = Connection()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
class UserValidator:
    """Non-conflicting class name"""

    def __init__(self):
        self.rules = []

    def add_rule(self, rule):
        self.rules.append(rule)
class AuthManager:
    """Non-conflicting class name"""

    def __init__(self):
        self.users = {}
        self.base_initialized = base_init()

    def add_user(self, user):
        self.users[user.username] = user

    def process_auth(self, username, data):
        return process(f"{username}:{data}")
if __name__ == "__main__":
    connection = Connection()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
class UserValidator:
    """Non-conflicting class name"""

    def __init__(self):
        self.rules = []

    def add_rule(self, rule):
        self.rules.append(rule)
class AuthManager:
    """Non-conflicting class name"""

    def __init__(self):
        self.users = {}
        self.base_initialized = base_init()

    def add_user(self, user):
        self.users[user.username] = user

    def process_auth(self, username, data):
        return process(f"{username}:{data}")
if __name__ == "__main__":
    connection = Connection()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
class AuthManager:
    """Non-conflicting class name"""

    def __init__(self):
        self.users = {}
        self.base_initialized = base_init()

    def add_user(self, user):
        self.users[user.username] = user

    def process_auth(self, username, data):
        return process(f"{username}:{data}")
if __name__ == "__main__":
    connection = Connection()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
class AuthManager:
    """Non-conflicting class name"""

    def __init__(self):
        self.users = {}
        self.base_initialized = base_init()

    def add_user(self, user):
        self.users[user.username] = user

    def process_auth(self, username, data):
        return process(f"{username}:{data}")
base.validate = validate
base.validate = validate
base.get_message = get_message
base.__init__ = __init__
base.process = process
base.process = process
base.Connection = Connection
base.initialize = initialize
base.Logger = Logger
base.Logger = Logger
