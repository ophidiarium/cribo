---
source: crates/cribo/tests/test_bundling_snapshots.rs
input_file: crates/cribo/tests/fixtures/xfail_ast_rewriting_globals_collision/main.py
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

import types
class Connection_core_database_connection:
    """Database connection class"""

    def __init__(self, db_name="default"):
        self.db_name = db_name
        self.connected = False

    def connect(self):
        self.connected = True
        return f"db_connection_to_{self.db_name}"

    def execute(self, query):
        if not self.connected:
            raise RuntimeError("Not connected")
        return format_result(f"Query: {query}")
validate_core_database_connection = lambda x: f"db_validate: {x}"
class Connection_core_database_connection:
    """Database connection class"""

    def __init__(self, db_name="default"):
        self.db_name = db_name
        self.connected = False

    def connect(self):
        self.connected = True
        return f"db_connection_to_{self.db_name}"

    def execute(self, query):
        if not self.connected:
            raise RuntimeError("Not connected")
        return format_result(f"Query: {query}")
def process_core_database_connection(data):
    """Process function in database module"""
    clean_data = sanitize(data)
    return f"db_process: {clean_data}"
process_core_database_connection = None
core_database_connection = types.SimpleNamespace()
core_database_connection.Connection = Connection_core_database_connection
core_database_connection.validate = validate_core_database_connection
core_database_connection.process = process_core_database_connection
core_database_connection.process = process_core_database_connection
User_models_user = None
class Logger_models_user:
    """User module logger - different from utils and base Logger"""

    def __init__(self, context):
        self.context = context
        self.base_logger = BaseLogger(context)
        self.util_logger = UtilLogger(context)

    def get_message(self):
        return f"user_logger_{self.context}"

    def log_all(self):
        return [self.get_message(), self.base_logger.get_message(), self.util_logger.get_message()]
Connection_models_user = type("Connection", (), {"source": "models.user"})
class User_models_user:
    """User model class"""

    def __init__(self, name):
        self.name = name
        self.logger = Logger("user")

    def process(self):
        return f"User.process: {self.name}"
models_user = types.SimpleNamespace()
models_user.User = User_models_user
models_user.Logger = Logger_models_user
models_user.Connection = Connection_models_user
models_user.User = User_models_user
def validate_models_base(data):
    """Validate function that uses imported validate"""
    base_check = f"base_validate: {data}"
    util_check = util_validate(data)
    return f"{base_check} + {util_check}"
validate_models_base = 123
def process_models_base(data):
    """Process function in base module"""
    return f"base_process: {data} (overrides lambda)"
process_models_base = lambda x: f"base_process: {x}"
Connection_models_base = []
def initialize_models_base():
    """Initialize base module"""
    global Connection
    Connection = type("Connection", (), {"type": "base_connection"})
    return "base_initialized"
class Logger_models_base:
    """Base logger class"""

    def __init__(self, prefix="BASE"):
        self.prefix = prefix

    def get_message(self):
        return f"base_logger_{self.prefix}"
Logger_models_base = None
models_base = types.SimpleNamespace()
models_base.validate = validate_models_base
models_base.validate = validate_models_base
models_base.process = process_models_base
models_base.process = process_models_base
models_base.Connection = Connection_models_base
models_base.initialize = initialize_models_base
models_base.Logger = Logger_models_base
models_base.Logger = Logger_models_base
def validate_services_auth_manager(data):
    """Validate function in auth module"""
    if not isinstance(data, str):
        return f"auth_validate_failed: {data}"
    return f"auth_validate: {data}"
Logger_services_auth_manager = set()
def validate_services_auth_manager(data):
    """Validate function in auth module"""
    if not isinstance(data, str):
        return f"auth_validate_failed: {data}"
    return f"auth_validate: {data}"
User_services_auth_manager = "auth_user_string"
def process_services_auth_manager(data):
    """Process function in auth module"""
    sanitized = sanitize(data)
    return f"auth_process: {sanitized}"
validate_services_auth_manager = None
class User_services_auth_manager:
    """Auth user class"""

    def __init__(self, username):
        self.username = username
        self.connection = Connection

    def authenticate(self):
        return f"auth_user_{self.username}"
class Connection_services_auth_manager:
    """Auth connection - overrides the global dict"""

    def __init__(self):
        self.db_conn = DBConnection("auth_db")
        self.status = "auth_connection"

    def connect(self):
        db_result = self.db_conn.connect()
        return f"auth_wrapped_{db_result}"
process_services_auth_manager = [1, 2, 3]
Connection_services_auth_manager = {"auth": True}
services_auth_manager = types.SimpleNamespace()
services_auth_manager.Logger = Logger_services_auth_manager
services_auth_manager.validate = validate_services_auth_manager
services_auth_manager.User = User_services_auth_manager
services_auth_manager.process = process_services_auth_manager
services_auth_manager.validate = validate_services_auth_manager
services_auth_manager.User = User_services_auth_manager
services_auth_manager.Connection = Connection_services_auth_manager
services_auth_manager.process = process_services_auth_manager
services_auth_manager.Connection = Connection_services_auth_manager
def validate_core_utils_helpers(data):
    """Validate function in utils module"""
    if data in validate_cache:
        return validate_cache[data]
    result = f"utils_validate: {data}"
    validate_cache[data] = result
    return result
Logger_core_utils_helpers = str
def format_result_core_utils_helpers(result):
    """Another utility function"""
    return f"formatted: {result}"
def validate_core_utils_helpers(data):
    """Validate function in utils module"""
    if data in validate_cache:
        return validate_cache[data]
    result = f"utils_validate: {data}"
    validate_cache[data] = result
    return result
def sanitize_core_utils_helpers(text):
    """Utility function without conflicts"""
    return text.strip().lower()
validate_cache = {}
def process_core_utils_helpers(data):
    """Process function in utils module"""
    global process_count
    process_count += 1
    return f"utils_process: {data} (#{process_count})"
process_count = 0
class Logger_core_utils_helpers:
    """Logger class in utils module"""

    def __init__(self, name):
        self.name = name
        self.messages = []

    def log(self, message):
        self.messages.append(f"[{self.name}] {message}")

    def get_message(self):
        return f"utils_logger_{self.name}"
core_utils_helpers = types.SimpleNamespace()
core_utils_helpers.Logger = Logger_core_utils_helpers
core_utils_helpers.format_result = format_result_core_utils_helpers
core_utils_helpers.validate = validate_core_utils_helpers
core_utils_helpers.sanitize = sanitize_core_utils_helpers
core_utils_helpers.validate_cache = validate_cache
core_utils_helpers.process = process_core_utils_helpers
core_utils_helpers.process_count = process_count
core_utils_helpers.Logger = Logger_core_utils_helpers
auth_process = services_auth_manager.process
User = services_auth_manager.User
auth_validate = services_auth_manager.validate
db_process = core_database_connection.process
UserModel = models_user.User
process_user = models_user.process_user
Logger = models_user.Logger
process = core_utils_helpers.process
UtilLogger = core_utils_helpers.Logger
validate = core_utils_helpers.validate
base = models_base
"""\nComprehensive AST rewriter test fixture - Main entry point\nThis module demonstrates complex naming conflicts and import scenarios\nWITHOUT circular dependencies\n"""
result = 42
connection = None
def validate(data):
    """This validate function conflicts with imported validate functions"""
    return f"main_validate: {data}"
def process(data):
    """This process function conflicts with multiple imported process functions"""
    return f"main_process: {data}"
class User:
    """This User class conflicts with imported User classes"""

    def __init__(self, name):
        self.name = name
        self.result = self._process_name(name)

    def _process_name(self, name):
        return f"main_user: {name}"
class User:
    """This User class conflicts with imported User classes"""

    def __init__(self, name):
        self.name = name
        self.result = self._process_name(name)

    def _process_name(self, name):
        return f"main_user: {name}"
class User:
    """This User class conflicts with imported User classes"""

    def __init__(self, name):
        self.name = name
        self.result = self._process_name(name)

    def _process_name(self, name):
        return f"main_user: {name}"
class User:
    """This User class conflicts with imported User classes"""

    def __init__(self, name):
        self.name = name
        self.result = self._process_name(name)

    def _process_name(self, name):
        return f"main_user: {name}"
class Connection:
    """Connection class that conflicts with database connection"""

    def __init__(self):
        self.status = "disconnected"

    def connect(self):
        global connection
        connection = self
        return "main_connection_established"
class Connection:
    """Connection class that conflicts with database connection"""

    def __init__(self):
        self.status = "disconnected"

    def connect(self):
        global connection
        connection = self
        return "main_connection_established"
class Connection:
    """Connection class that conflicts with database connection"""

    def __init__(self):
        self.status = "disconnected"

    def connect(self):
        global connection
        connection = self
        return "main_connection_established"
class Connection:
    """Connection class that conflicts with database connection"""

    def __init__(self):
        self.status = "disconnected"

    def connect(self):
        global connection
        connection = self
        return "main_connection_established"
def main():
    """Main function demonstrating all the conflicts in action"""
    db_result = db_process("database_data")
    util_result = process("utility_data")
    auth_result = auth_process("auth_data")
    util_logger = UtilLogger("util")
    model_logger = Logger("model")
    auth_user = User("auth_type")
    model_user = UserModel("model_type")
    service_user = User("service_type")
    local_validate_result = validate("local_data")
    auth_validate_result = auth_validate("auth_data")
    util_validate_result = validate("util_data")
    result = db_result + util_result + auth_result
    base_result = base.initialize()
    final_result = {"process_results": [db_result, util_result, auth_result], "validation_results": [local_validate_result, auth_validate_result, util_validate_result], "user_types": [auth_user.name, model_user.name, service_user.name], "logger_messages": [util_logger.get_message(), model_logger.get_message()], "base_init": base_result, "total": result + str(globals()["result"])}
    return final_result
if __name__ == "__main__":
    connection = Connection()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
if __name__ == "__main__":
    connection = Connection()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
if __name__ == "__main__":
    connection = Connection()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
if __name__ == "__main__":
    connection = Connection()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
if __name__ == "__main__":
    connection = Connection()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
if __name__ == "__main__":
    connection = Connection()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
