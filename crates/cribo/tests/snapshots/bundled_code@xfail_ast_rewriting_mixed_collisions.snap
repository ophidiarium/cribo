---
source: crates/cribo/tests/test_bundling_snapshots.rs
input_file: crates/cribo/tests/fixtures/xfail_ast_rewriting_mixed_collisions/main.py
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

import types
def validate_core_database_connection(data):
    """Database validate function - another conflict"""
    if not data:
        return False
    return f"db_valid: {data}"
result_core_database_connection = []
def connect_core_database_connection():
    """Module-level connect function"""
    global connection
    if connection is None:
        connection = Connection()
    return connection.connect()
def process_core_database_connection(data):
    """Database process function - conflicts with other process functions"""
    global result
    validated = helper_validate(data)
    user_result = process_user(data)
    processed = {"db_process": True, "data": validated, "user_processing": user_result, "timestamp": "2024-01-01"}
    result.append(processed)
    return f"db_processed: {data}"
def connect_core_database_connection():
    """Module-level connect function"""
    global connection
    if connection is None:
        connection = Connection()
    return connection.connect()
def validate_core_database_connection(data):
    """Database validate function - another conflict"""
    if not data:
        return False
    return f"db_valid: {data}"
process_core_database_connection = process
core_database_connection = types.SimpleNamespace()
core_database_connection.validate = validate_core_database_connection
core_database_connection.result = result_core_database_connection
core_database_connection.process = process_core_database_connection
core_database_connection.connect = connect_core_database_connection
core_database_connection.process = process_core_database_connection
def process_models_user(data: Any) -> str:
    """Module process function - major conflict"""
    if isinstance(data, dict):
        return process_user(data)
    else:
        return f"model_process_generic: {data}"
def complex_operation(User: Any=None, Logger: Any=None, process: Any=None, validate: Any=None, result: Any=None, connection: Any=None) -> Dict[str, Any]:
    """Function with all parameter names conflicting with globals/classes"""
    operation_result = {"user_param": User, "logger_param": Logger, "process_param": process, "validate_param": validate, "result_param": result, "connection_param": connection}
    User = globals()["User"]
    Logger = globals()["Logger"]
    if operation_result["user_param"]:
        user = User("complex_user")
        logger = Logger("complex_operation")
        operation_result["created_user"] = user.name
        operation_result["created_logger"] = logger.context
    return operation_result
def process_user_models_user(data: Any) -> str:
    """Module function with naming conflicts"""
    global result
    Logger = globals()["Logger"]
    validate = lambda x: x is not None
    logger = Logger("process_user")
    is_valid = validate(data)
    if is_valid:
        logger._log_process(f"Processing user data: {data}")
        processed = f"model_user_processed: {data}"
    else:
        processed = "model_user_invalid_data"
    result["last_process"] = processed
    return processed
def process_models_user(data: Any) -> str:
    """Module process function - major conflict"""
    if isinstance(data, dict):
        return process_user(data)
    else:
        return f"model_process_generic: {data}"
User_models_user = User
process_models_user = process
class Logger_models_user:
    """Model Logger class - conflicts with other Logger classes"""

    def __init__(self, context: str):
        self.context = context
        self.entries = []
        self.process = self._log_process

    def _log_process(self, message: str) -> None:
        self.entries.append(f"{self.context}: {message}")

    def get_message(self) -> str:
        return f"Model Logger: {self.context}"

    def validate(self, entry: str) -> bool:
        """Method with name that conflicts with global functions"""
        return len(entry) > 0
def complex_operation(User: Any=None, Logger: Any=None, process: Any=None, validate: Any=None, result: Any=None, connection: Any=None) -> Dict[str, Any]:
    """Function with all parameter names conflicting with globals/classes"""
    operation_result = {"user_param": User, "logger_param": Logger, "process_param": process, "validate_param": validate, "result_param": result, "connection_param": connection}
    User = globals()["User"]
    Logger = globals()["Logger"]
    if operation_result["user_param"]:
        user = User("complex_user")
        logger = Logger("complex_operation")
        operation_result["created_user"] = user.name
        operation_result["created_logger"] = logger.context
    return operation_result
def process_user_models_user(data: Any) -> str:
    """Module function with naming conflicts"""
    global result
    Logger = globals()["Logger"]
    validate = lambda x: x is not None
    logger = Logger("process_user")
    is_valid = validate(data)
    if is_valid:
        logger._log_process(f"Processing user data: {data}")
        processed = f"model_user_processed: {data}"
    else:
        processed = "model_user_invalid_data"
    result["last_process"] = processed
    return processed
models_user = types.SimpleNamespace()
models_user.process = process_models_user
models_user.User = User_models_user
models_user.process = process_models_user
models_user.Logger = Logger_models_user
models_user.complex_operation = complex_operation
models_user.process_user = process_user_models_user
class BaseModel:
    """Base model class with method name conflicts"""

    def __init__(self, model_type: str):
        self.model_type = model_type
        self.initialized = False
        self.validate = self._base_validate
        self.process = self._base_process
        self.Logger = UserLogger("base_model")

    def _base_validate(self, data: Any) -> bool:
        """Base validation using relative imports"""
        return core_validate(data)

    def _base_process(self, data: Any) -> str:
        """Base processing with conflicts"""
        validated = self.validate(data)
        if validated:
            self.Logger._log_process(f"Base processing: {data}")
            return f"base_processed: {data}"
        return "base_invalid"

    def initialize(self) -> str:
        """Initialize with name conflicts"""
        global result
        self.initialized = True
        result = f"base_initialized_{self.model_type}"
        return result
def connect_models_base() -> str:
    """Base connect function"""
    return "base_connected"
process_models_base = process
class BaseModel:
    """Base model class with method name conflicts"""

    def __init__(self, model_type: str):
        self.model_type = model_type
        self.initialized = False
        self.validate = self._base_validate
        self.process = self._base_process
        self.Logger = UserLogger("base_model")

    def _base_validate(self, data: Any) -> bool:
        """Base validation using relative imports"""
        return core_validate(data)

    def _base_process(self, data: Any) -> str:
        """Base processing with conflicts"""
        validated = self.validate(data)
        if validated:
            self.Logger._log_process(f"Base processing: {data}")
            return f"base_processed: {data}"
        return "base_invalid"

    def initialize(self) -> str:
        """Initialize with name conflicts"""
        global result
        self.initialized = True
        result = f"base_initialized_{self.model_type}"
        return result
class Logger_models_base:
    """Base Logger class - yet another Logger conflict"""

    def __init__(self, source: str):
        self.source = source
        self.logs = []

    def log(self, message: str) -> None:
        self.logs.append(f"[BASE {self.source}] {message}")

    def process(self, log_data: Any) -> str:
        """Logger process method - conflicts with global process"""
        self.log(f"Processing: {log_data}")
        return f"base_logger_process: {log_data}"
def shadow_test(validate: Any=None, process: Any=None, Logger: Any=None, result: Any=None, initialize: Any=None) -> Dict[str, Any]:
    """Function that shadows all major conflict names with parameters"""
    shadows = {"validate_param": validate, "process_param": process, "Logger_param": Logger, "result_param": result, "initialize_param": initialize}
    validate = globals()["validate"]
    process = globals()["process"]
    Logger = globals()["Logger"]
    validation_result = validate("test_data")
    process_result = process("test_data")
    logger = Logger("shadow_test")
    shadows.update({"global_validate_result": validation_result, "global_process_result": process_result, "global_logger_source": logger.source})
    return shadows
result_models_base = "base_result"
Logger_models_base = Logger
def process_models_base(data: Any) -> str:
    """Base process function - conflicts everywhere"""
    global result
    validated = validate(data)
    if validated:
        processed = f"base_module_process: {data}"
    else:
        processed = "base_module_invalid"
    result = f"base_last_process: {processed}"
    return processed
def initialize_models_base() -> str:
    """Module initialization function"""
    global result
    base = BaseModel("default")
    init_result = base.initialize()
    logger = UserLogger("base_init")
    logger._log_process("Base module initialized")
    result = f"module_init: {init_result}"
    return result
validate_models_base = validate
process_models_base = "base_process_string"
def process_models_base(data: Any) -> str:
    """Base process function - conflicts everywhere"""
    global result
    validated = validate(data)
    if validated:
        processed = f"base_module_process: {data}"
    else:
        processed = "base_module_invalid"
    result = f"base_last_process: {processed}"
    return processed
models_base = types.SimpleNamespace()
models_base.connect = connect_models_base
models_base.process = process_models_base
models_base.BaseModel = BaseModel
models_base.Logger = Logger_models_base
models_base.shadow_test = shadow_test
models_base.result = result_models_base
models_base.Logger = Logger_models_base
models_base.process = process_models_base
models_base.initialize = initialize_models_base
models_base.validate = validate_models_base
models_base.process = process_models_base
validate_services_auth_manager = validate
class AuthManager:
    """Manager class with extensive conflicts"""

    def __init__(self):
        self.connections = []
        self.users = []
        self.process = self._manager_process
        self.validate = self._manager_validate
        self.User = None

    def _manager_process(self, data: Any) -> str:
        return f"manager_process: {data}"

    def _manager_validate(self, data: Any) -> bool:
        return data is not None

    def add_user(self, username: str, password: str) -> "User":
        """Method that creates User with local scope conflicts"""
        User = globals()["User"]
        user = User(username, password)
        self.users.append(user)
        self.User = user
        return user

    def process_all(self) -> Dict[str, Any]:
        """Method using conflicting names throughout"""
        result = []
        for User in self.users:
            user_result = process(User.username)
            validate_result = validate(User.password)
            connection = connect(User)
            connection_process = connection.process(User.username)
            result.append({"user": User.username, "process": user_result, "validate": validate_result, "connection": connection_process})
        return {"manager_results": result}
def validate_services_auth_manager(data: Any) -> str:
    """Auth validate function - conflicts with other validate functions"""
    if not data:
        return "auth_invalid"
    module_validate = globals().get("validate")
    if module_validate and module_validate is not validate and callable(module_validate):
        lambda_result = module_validate(data)
    else:
        lambda_result = f"fallback_{data}"
    return f"auth_valid: {data}, lambda: {lambda_result}"
class Connection_services_auth_manager:
    """Auth connection class - conflicts with DB Connection"""

    def __init__(self, auth_type: str="oauth"):
        self.auth_type = auth_type
        self.users = []

    def add_user(self, User: "User") -> None:
        """Add user with parameter name conflict"""
        self.users.append(User)

    def process(self, User: str) -> str:
        """Process with parameter name conflicts"""
        return f"auth_connection_process: {User}"
result_services_auth_manager = "auth_result"
def validate_services_auth_manager(data: Any) -> str:
    """Auth validate function - conflicts with other validate functions"""
    if not data:
        return "auth_invalid"
    module_validate = globals().get("validate")
    if module_validate and module_validate is not validate and callable(module_validate):
        lambda_result = module_validate(data)
    else:
        lambda_result = f"fallback_{data}"
    return f"auth_valid: {data}, lambda: {lambda_result}"
process_services_auth_manager = process
class AuthManager:
    """Manager class with extensive conflicts"""

    def __init__(self):
        self.connections = []
        self.users = []
        self.process = self._manager_process
        self.validate = self._manager_validate
        self.User = None

    def _manager_process(self, data: Any) -> str:
        return f"manager_process: {data}"

    def _manager_validate(self, data: Any) -> bool:
        return data is not None

    def add_user(self, username: str, password: str) -> "User":
        """Method that creates User with local scope conflicts"""
        User = globals()["User"]
        user = User(username, password)
        self.users.append(user)
        self.User = user
        return user

    def process_all(self) -> Dict[str, Any]:
        """Method using conflicting names throughout"""
        result = []
        for User in self.users:
            user_result = process(User.username)
            validate_result = validate(User.password)
            connection = connect(User)
            connection_process = connection.process(User.username)
            result.append({"user": User.username, "process": user_result, "validate": validate_result, "connection": connection_process})
        return {"manager_results": result}
def validate_services_auth_manager(data: Any) -> str:
    """Auth validate function - conflicts with other validate functions"""
    if not data:
        return "auth_invalid"
    module_validate = globals().get("validate")
    if module_validate and module_validate is not validate and callable(module_validate):
        lambda_result = module_validate(data)
    else:
        lambda_result = f"fallback_{data}"
    return f"auth_valid: {data}, lambda: {lambda_result}"
services_auth_manager = types.SimpleNamespace()
services_auth_manager.validate = validate_services_auth_manager
services_auth_manager.Connection = Connection_services_auth_manager
services_auth_manager.result = result_services_auth_manager
services_auth_manager.process = process_services_auth_manager
services_auth_manager.AuthManager = AuthManager
services_auth_manager.validate = validate_services_auth_manager
validate_core_utils_helpers = validate
result_core_utils_helpers = 0
process_core_utils_helpers = process
def process_with_conflicts(data: Any, User: str="param_user", result: int=100, Logger: Any=None) -> Dict[str, Any]:
    """Function with parameter names that conflict with globals and imports"""
    connection = connect()
    validate_result = validate(data)
    local_result = {"data": data, "user_param": User, "result_param": result, "logger_param": Logger, "validation": validate_result, "connection_type": connection.connection_type}
    return local_result
User_core_utils_helpers = "helper_user_string"
core_utils_helpers = types.SimpleNamespace()
core_utils_helpers.validate = validate_core_utils_helpers
core_utils_helpers.result = result_core_utils_helpers
core_utils_helpers.process = process_core_utils_helpers
core_utils_helpers.process_with_conflicts = process_with_conflicts
core_utils_helpers.User = User_core_utils_helpers
auth_process = services_auth_manager.process
User = services_auth_manager.User
auth_validate = services_auth_manager.validate
db_process = core_database_connection.process
UserModel = models_user.User
process_user = models_user.process_user
Logger = models_user.Logger
process = core_utils_helpers.process
UtilLogger = core_utils_helpers.Logger
validate = core_utils_helpers.validate
base = models_base.base
"""\nComprehensive AST rewriter test fixture - Main entry point\nThis module demonstrates complex naming conflicts and import scenarios\n"""
result = 42
connection = None
def validate(data):
    """This validate function conflicts with imported validate functions"""
    return f"main_validate: {data}"
def process(data):
    """This process function conflicts with multiple imported process functions"""
    return f"main_process: {data}"
class User:
    """This User class conflicts with imported User classes"""

    def __init__(self, name):
        self.name = name
        self.result = self._process_name(name)

    def _process_name(self, name):
        return f"main_user: {name}"
class User:
    """This User class conflicts with imported User classes"""

    def __init__(self, name):
        self.name = name
        self.result = self._process_name(name)

    def _process_name(self, name):
        return f"main_user: {name}"
class User:
    """This User class conflicts with imported User classes"""

    def __init__(self, name):
        self.name = name
        self.result = self._process_name(name)

    def _process_name(self, name):
        return f"main_user: {name}"
class User:
    """This User class conflicts with imported User classes"""

    def __init__(self, name):
        self.name = name
        self.result = self._process_name(name)

    def _process_name(self, name):
        return f"main_user: {name}"
class Connection:
    """Connection class that conflicts with database connection"""

    def __init__(self):
        self.status = "disconnected"

    def connect(self):
        global connection
        connection = self
        return "main_connection_established"
class Connection:
    """Connection class that conflicts with database connection"""

    def __init__(self):
        self.status = "disconnected"

    def connect(self):
        global connection
        connection = self
        return "main_connection_established"
class Connection:
    """Connection class that conflicts with database connection"""

    def __init__(self):
        self.status = "disconnected"

    def connect(self):
        global connection
        connection = self
        return "main_connection_established"
class Connection:
    """Connection class that conflicts with database connection"""

    def __init__(self):
        self.status = "disconnected"

    def connect(self):
        global connection
        connection = self
        return "main_connection_established"
def main():
    """Main function demonstrating all the conflicts in action"""
    db_result = db_process("database_data")
    util_result = process("utility_data")
    auth_result = auth_process("auth_data")
    util_logger = UtilLogger("util")
    model_logger = Logger("model")
    auth_user = User("auth_type")
    model_user = UserModel("model_type")
    service_user = User("service_type")
    local_validate_result = validate("local_data")
    auth_validate_result = auth_validate("auth_data")
    util_validate_result = validate("util_data")
    result = db_result + util_result + auth_result
    base_result = base.initialize()
    final_result = {"process_results": [db_result, util_result, auth_result], "validation_results": [local_validate_result, auth_validate_result, util_validate_result], "user_types": [auth_user.name, model_user.name, service_user.name], "logger_messages": [util_logger.get_message(), model_logger.get_message()], "base_init": base_result, "total": result + str(globals()["result"])}
    return final_result
if __name__ == "__main__":
    connection = Connection()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
if __name__ == "__main__":
    connection = Connection()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
if __name__ == "__main__":
    connection = Connection()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
if __name__ == "__main__":
    connection = Connection()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
if __name__ == "__main__":
    connection = Connection()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
if __name__ == "__main__":
    connection = Connection()
    connection.connect()
    results = main()
    print("Comprehensive AST rewriter test completed")
    print(f"Final results: {results}")
