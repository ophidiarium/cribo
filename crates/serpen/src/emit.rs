use anyhow::{Context, Result};
use std::collections::HashSet;
use std::fs;
use std::path::Path;

use crate::dependency_graph::ModuleNode;
use crate::resolver::{ImportType, ModuleResolver};

/// Type alias for import sets to reduce complexity
type ImportSets = (HashSet<String>, HashSet<String>);

pub struct CodeEmitter {
  resolver: ModuleResolver,
  _preserve_comments: bool,
  _preserve_type_hints: bool,
}

impl CodeEmitter {
  pub fn new(resolver: ModuleResolver, preserve_comments: bool, preserve_type_hints: bool) -> Self {
    Self {
      resolver,
      _preserve_comments: preserve_comments,
      _preserve_type_hints: preserve_type_hints,
    }
  }

  /// Helper method to classify and add import to appropriate set
  fn classify_and_add_import(
    &self,
    import: &str,
    third_party_imports: &mut HashSet<String>,
    stdlib_imports: &mut HashSet<String>,
  ) {
    match self.resolver.classify_import(import) {
      ImportType::ThirdParty => {
        third_party_imports.insert(import.to_string());
      }
      ImportType::StandardLibrary => {
        stdlib_imports.insert(import.to_string());
      }
      ImportType::FirstParty => {
        // Will be inlined, so skip
      }
    }
  }

  /// Collect imports and categorize them by type
  fn collect_import_sets(&self, modules: &[&ModuleNode]) -> ImportSets {
    let mut third_party_imports = HashSet::new();
    let mut stdlib_imports = HashSet::new();

    for module in modules {
      for import in &module.imports {
        self.classify_and_add_import(import, &mut third_party_imports, &mut stdlib_imports);
      }
    }

    (third_party_imports, stdlib_imports)
  }

  /// Generate bundled Python code from sorted modules
  pub fn emit_bundle(&mut self, modules: &[&ModuleNode], entry_module: &str) -> Result<String> {
    let mut output = vec![
      "#!/usr/bin/env python3".to_string(),
      "# Generated by Serpen - Python Source Bundler".to_string(),
      "# https://github.com/tinovyatkin/serpen".to_string(),
      "".to_string(),
    ];

    // Collect all third-party imports that need to be preserved
    let (third_party_imports, stdlib_imports) = self.collect_import_sets(modules);

    // Add preserved imports at the top
    if !stdlib_imports.is_empty() || !third_party_imports.is_empty() {
      output.push("# Preserved imports".to_string());

      // Standard library imports first
      let mut sorted_stdlib: Vec<_> = stdlib_imports.into_iter().collect();
      sorted_stdlib.sort();
      for import in &sorted_stdlib {
        output.push(self.format_import_statement(import));
      }

      if !sorted_stdlib.is_empty() && !third_party_imports.is_empty() {
        output.push("".to_string());
      }

      // Third-party imports
      let mut sorted_third_party: Vec<_> = third_party_imports.into_iter().collect();
      sorted_third_party.sort();
      for import in sorted_third_party {
        output.push(self.format_import_statement(&import));
      }

      output.push("".to_string());
    }

    // Process each module in dependency order
    for module in modules {
      // Skip entry module for now - we'll add it at the end
      if module.name == entry_module {
        continue;
      }

      output.push(format!("# ─ Module: {} ─", module.name));

      let module_code = self.process_module_file(&module.path, &module.name)?;
      output.push(module_code);
      output.push("".to_string());
    }

    // Add entry module last
    if let Some(entry_module_node) = modules.iter().find(|m| m.name == entry_module) {
      output.push(format!("# ─ Entry Module: {} ─", entry_module));
      let entry_code =
        self.process_module_file(&entry_module_node.path, &entry_module_node.name)?;
      output.push(entry_code);
    }

    Ok(output.join("\n"))
  }

  /// Process a single module file, removing inlined imports
  fn process_module_file(&mut self, file_path: &Path, _module_name: &str) -> Result<String> {
    let source = fs::read_to_string(file_path)
      .with_context(|| format!("Failed to read module file: {:?}", file_path))?;

    // Simple approach: process line by line and filter out first-party imports
    let mut output_lines = Vec::new();

    for line in source.lines() {
      let trimmed = line.trim();

      if self.should_process_import_line(trimmed, &mut output_lines, line) {
        continue;
      }

      // Keep all non-import lines
      output_lines.push(line.to_string());
    }

    Ok(output_lines.join("\n"))
  }

  /// Process import lines and return true if the line was handled
  fn should_process_import_line(
    &mut self,
    trimmed: &str,
    output_lines: &mut Vec<String>,
    line: &str,
  ) -> bool {
    if trimmed.starts_with("from ") && trimmed.contains(" import ") {
      self.process_from_import(trimmed, output_lines, line);
      true
    } else if trimmed.starts_with("import ") {
      self.process_import_statement(trimmed, output_lines, line);
      true
    } else {
      false
    }
  }

  /// Process "from module import ..." statements
  fn process_from_import(&mut self, trimmed: &str, output_lines: &mut Vec<String>, line: &str) {
    if let Some(module_part) = trimmed
      .strip_prefix("from ")
      .and_then(|s| s.split(" import ").next())
    {
      let module_name = module_part.trim();
      match self.resolver.classify_import(module_name) {
        ImportType::FirstParty => {
          // Skip first-party imports - they'll be inlined
        }
        ImportType::ThirdParty | ImportType::StandardLibrary => {
          // Keep third-party and stdlib imports
          output_lines.push(line.to_string());
        }
      }
    } else {
      // Keep malformed import lines as-is
      output_lines.push(line.to_string());
    }
  }

  /// Process "import module" statements
  fn process_import_statement(
    &mut self,
    trimmed: &str,
    output_lines: &mut Vec<String>,
    line: &str,
  ) {
    let imports_part = trimmed.strip_prefix("import ").unwrap();
    let modules: Vec<&str> = imports_part.split(',').map(|s| s.trim()).collect();

    let keep_line = modules.iter().any(|module| {
      // Handle "import module as alias"
      let module_name = module.split(" as ").next().unwrap_or(module).trim();
      matches!(
        self.resolver.classify_import(module_name),
        ImportType::ThirdParty | ImportType::StandardLibrary
      )
    });

    if keep_line {
      output_lines.push(line.to_string());
    }
    // Skip lines with only first-party imports
  }

  /// Safely format an import statement, validating the input
  fn format_import_statement(&self, module_name: &str) -> String {
    // Validate that the import string looks like a simple module name
    // Module names should contain only alphanumeric characters, underscores, and dots
    if module_name
      .chars()
      .all(|c| c.is_alphanumeric() || c == '_' || c == '.')
      && !module_name.is_empty()
      && !module_name.contains(' ')
    {
      format!("import {}", module_name)
    } else {
      // If it doesn't look like a simple module name, treat it as a pre-formatted import
      // This handles cases where the import might already be formatted or contain aliases
      if module_name.starts_with("import ") || module_name.starts_with("from ") {
        module_name.to_string()
      } else {
        // Fallback: still format as import but add a comment indicating potential issue
        format!(
          "import {}  # Warning: unusual module name format",
          module_name
        )
      }
    }
  }

  /// Generate requirements.txt content from third-party imports
  pub fn generate_requirements(&mut self, modules: &[&ModuleNode]) -> Result<String> {
    let mut third_party_imports = HashSet::new();

    for module in modules {
      self.collect_third_party_imports_from_module(module, &mut third_party_imports);
    }

    let mut requirements: Vec<String> = third_party_imports.into_iter().collect();
    requirements.sort();

    Ok(requirements.join("\n"))
  }

  /// Collect third-party imports from a single module
  fn collect_third_party_imports_from_module(
    &mut self,
    module: &ModuleNode,
    third_party_imports: &mut HashSet<String>,
  ) {
    for import in &module.imports {
      if let ImportType::ThirdParty = self.resolver.classify_import(import) {
        // Extract top-level package name
        let package_name = import.split('.').next().unwrap_or(import);
        third_party_imports.insert(package_name.to_string());
      }
    }
  }
}
