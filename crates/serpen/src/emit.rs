use anyhow::{Context, Result};
use std::collections::HashSet;
use std::fs;
use std::path::Path;

use crate::dependency_graph::ModuleNode;
use crate::resolver::{ImportType, ModuleResolver};
use rustpython_parser::ast::{Mod, Stmt};
use rustpython_parser::{parse, Mode};

/// Type alias for import sets to reduce complexity
type ImportSets = (HashSet<String>, HashSet<String>);

pub struct CodeEmitter {
  resolver: ModuleResolver,
  _preserve_comments: bool,
  _preserve_type_hints: bool,
}

impl CodeEmitter {
  pub fn new(resolver: ModuleResolver, preserve_comments: bool, preserve_type_hints: bool) -> Self {
    Self {
      resolver,
      _preserve_comments: preserve_comments,
      _preserve_type_hints: preserve_type_hints,
    }
  }

  /// Helper method to classify and add import to appropriate set
  fn classify_and_add_import(
    &self,
    import: &str,
    third_party_imports: &mut HashSet<String>,
    stdlib_imports: &mut HashSet<String>,
  ) {
    match self.resolver.classify_import(import) {
      ImportType::ThirdParty => {
        third_party_imports.insert(import.to_string());
      }
      ImportType::StandardLibrary => {
        stdlib_imports.insert(import.to_string());
      }
      ImportType::FirstParty => {
        // Will be inlined, so skip
      }
    }
  }

  /// Collect imports and categorize them by type
  fn collect_import_sets(&self, modules: &[&ModuleNode]) -> ImportSets {
    let mut third_party_imports = HashSet::new();
    let mut stdlib_imports = HashSet::new();

    for module in modules {
      for import in &module.imports {
        self.classify_and_add_import(import, &mut third_party_imports, &mut stdlib_imports);
      }
    }

    (third_party_imports, stdlib_imports)
  }

  /// Generate bundled Python code from sorted modules
  pub fn emit_bundle(&mut self, modules: &[&ModuleNode], entry_module: &str) -> Result<String> {
    let mut output = vec![
      "#!/usr/bin/env python3".to_string(),
      "# Generated by Serpen - Python Source Bundler".to_string(),
      "# https://github.com/tinovyatkin/serpen".to_string(),
      "".to_string(),
    ];

    // Collect all third-party imports that need to be preserved
    let (third_party_imports, stdlib_imports) = self.collect_import_sets(modules);

    // Add preserved imports at the top
    if !stdlib_imports.is_empty() || !third_party_imports.is_empty() {
      output.push("# Preserved imports".to_string());

      // Standard library imports first
      let mut sorted_stdlib: Vec<_> = stdlib_imports.into_iter().collect();
      sorted_stdlib.sort();
      for import in &sorted_stdlib {
        output.push(self.format_import_statement(import));
      }

      if !sorted_stdlib.is_empty() && !third_party_imports.is_empty() {
        output.push("".to_string());
      }

      // Third-party imports
      let mut sorted_third_party: Vec<_> = third_party_imports.into_iter().collect();
      sorted_third_party.sort();
      for import in sorted_third_party {
        output.push(self.format_import_statement(&import));
      }

      output.push("".to_string());
    }

    // Process each module in dependency order
    for module in modules {
      // Skip entry module for now - we'll add it at the end
      if module.name == entry_module {
        continue;
      }

      output.push(format!("# ─ Module: {} ─", module.name));

      let module_code = self.process_module_file(&module.path, &module.name)?;
      output.push(module_code);
      output.push("".to_string());
    }

    // Add entry module last
    if let Some(entry_module_node) = modules.iter().find(|m| m.name == entry_module) {
      output.push(format!("# ─ Entry Module: {} ─", entry_module));
      let entry_code =
        self.process_module_file(&entry_module_node.path, &entry_module_node.name)?;
      output.push(entry_code);
    }

    Ok(output.join("\n"))
  }

  /// Process a single module file, removing inlined imports
  fn process_module_file(&mut self, file_path: &Path, _module_name: &str) -> Result<String> {
    let source = fs::read_to_string(file_path)
      .with_context(|| format!("Failed to read module file: {:?}", file_path))?;

    // Collect first-party imports using AST for accuracy
    let first_party_imports = self.collect_first_party_imports_from_file(&source)?;

    // Enhanced line-based processing with triple-quote and multi-line handling
    let mut output_lines = Vec::new();
    let mut in_triple = false;
    let mut buf: Vec<String> = Vec::new();

    for line in source.lines() {
      // Triple-quoted string handling
      if in_triple {
        output_lines.push(line.to_string());
        in_triple = !(line.contains("'''") || line.contains("\"\"\""));
        continue;
      }

      if self.is_triple_quote_start(line) {
        in_triple = true;
        output_lines.push(line.to_string());
        continue;
      }

      // Accumulate logical lines (handle backslash continuations and unmatched parentheses)
      buf.push(line.to_string());
      let joined = buf.join("\n");

      if self.is_statement_continuation(&joined, line) {
        continue;
      }

      // Logical statement ready - process it
      self.process_logical_statement(&joined, &first_party_imports, &mut output_lines);
      buf.clear();
    }

    // Flush any remaining buffer
    for line in buf {
      output_lines.push(line);
    }

    Ok(output_lines.join("\n"))
  }

  /// Collect first-party imports from a file using AST parsing
  fn collect_first_party_imports_from_file(&self, source: &str) -> Result<HashSet<String>> {
    let mut first_party_imports = HashSet::new();

    if let Ok(Mod::Module(module)) = parse(source, Mode::Module, "module") {
      for stmt in &module.body {
        self.collect_first_party_from_statement(stmt, &mut first_party_imports);
      }
    }

    log::debug!("Collected first-party imports: {:?}", first_party_imports);
    Ok(first_party_imports)
  }

  /// Extract first-party imports from an AST statement
  fn collect_first_party_from_statement(&self, stmt: &Stmt, imports: &mut HashSet<String>) {
    match stmt {
      Stmt::Import(import_stmt) => {
        self.collect_first_party_from_import(import_stmt, imports);
      }
      Stmt::ImportFrom(import_from_stmt) => {
        self.collect_first_party_from_import_from(import_from_stmt, imports);
      }
      _ => {}
    }
  }

  /// Helper to collect first-party imports from "from ... import" statements
  fn collect_first_party_from_import_from(
    &self,
    import_from_stmt: &rustpython_parser::ast::StmtImportFrom,
    imports: &mut HashSet<String>,
  ) {
    // Handle relative imports (e.g., `from . import x`) as first-party
    if import_from_stmt.module.is_none() {
      if import_from_stmt.level.is_some() {
        // Insert empty string marker for relative import
        imports.insert(String::new());
      }
      return;
    }
    let module = import_from_stmt.module.as_ref().unwrap();

    let module_name = module.as_str();
    if matches!(
      self.resolver.classify_import(module_name),
      ImportType::FirstParty
    ) {
      imports.insert(module_name.to_string());
    }
  }

  /// Helper to collect first-party imports from regular import statements
  fn collect_first_party_from_import(
    &self,
    import_stmt: &rustpython_parser::ast::StmtImport,
    imports: &mut HashSet<String>,
  ) {
    for alias in &import_stmt.names {
      let import_name = alias.name.as_str();
      if matches!(
        self.resolver.classify_import(import_name),
        ImportType::FirstParty
      ) {
        imports.insert(import_name.to_string());
      }
    }
  }

  /// Check if a line starts a triple-quoted string (multi-line)
  fn is_triple_quote_start(&self, line: &str) -> bool {
    let trimmed = line.trim_start();

    // Check for triple quotes
    if trimmed.starts_with("'''") {
      // Count occurrences of ''' in the line
      let count = trimmed.matches("'''").count();
      // If there's only one occurrence, it's the start of a multi-line string
      return count == 1;
    }

    if trimmed.starts_with("\"\"\"") {
      // Count occurrences of """ in the line
      let count = trimmed.matches("\"\"\"").count();
      // If there's only one occurrence, it's the start of a multi-line string
      return count == 1;
    }

    false
  }

  /// Check if the current statement should be continued (backslash or unmatched parentheses)
  fn is_statement_continuation(&self, joined: &str, last_line: &str) -> bool {
    if last_line.trim_end().ends_with('\\') {
      return true;
    }

    let open_paren = joined.matches('(').count();
    let close_paren = joined.matches(')').count();
    open_paren > close_paren
  }

  /// Process a complete logical statement
  fn process_logical_statement(
    &self,
    statement: &str,
    first_party_imports: &HashSet<String>,
    output_lines: &mut Vec<String>,
  ) {
    let trimmed = statement.trim();
    let is_import = trimmed.starts_with("import ")
      || (trimmed.starts_with("from ") && trimmed.contains(" import "));

    if !is_import {
      // Non-import: emit original text
      output_lines.extend(statement.lines().map(str::to_string));
      return;
    }

    // Check if all modules in this import are first-party; if so, skip
    let modules = self.extract_import_modules(trimmed);
    log::debug!(
      "Processing import statement: '{}', extracted modules: {:?}",
      trimmed,
      modules
    );

    let all_first_party = modules
      .iter()
      .all(|module_name| first_party_imports.contains(module_name));

    log::debug!(
      "All modules first-party: {}, first_party_imports: {:?}",
      all_first_party,
      first_party_imports
    );

    if !all_first_party {
      // Preserve statement if it contains non-first-party imports
      output_lines.extend(statement.lines().map(str::to_string));
    } else {
      log::debug!("Skipping first-party import: {}", trimmed);
    }
    // Skip statements with only first-party imports
  }

  /// Extract module names from an import statement
  fn extract_import_modules(&self, statement: &str) -> Vec<String> {
    if statement.starts_with("from ") {
      if let Some(module_part) = statement
        .strip_prefix("from ")
        .and_then(|s| s.split(" import ").next())
      {
        vec![module_part.trim().to_string()]
      } else {
        vec![]
      }
    } else if let Some(imports_part) = statement.strip_prefix("import ") {
      imports_part
        .split(',')
        .map(|s| s.split(" as ").next().unwrap_or(s).trim().to_string())
        .collect()
    } else {
      vec![]
    }
  }

  /// Safely format an import statement, validating the input
  fn format_import_statement(&self, module_name: &str) -> String {
    // Validate that the import string looks like a simple module name
    // Module names should contain only alphanumeric characters, underscores, and dots
    if module_name
      .chars()
      .all(|c| c.is_alphanumeric() || c == '_' || c == '.')
      && !module_name.is_empty()
      && !module_name.contains(' ')
    {
      format!("import {}", module_name)
    } else {
      // If it doesn't look like a simple module name, treat it as a pre-formatted import
      // This handles cases where the import might already be formatted or contain aliases
      if module_name.starts_with("import ") || module_name.starts_with("from ") {
        module_name.to_string()
      } else {
        // Fallback: still format as import but add a comment indicating potential issue
        format!(
          "import {}  # Warning: unusual module name format",
          module_name
        )
      }
    }
  }

  /// Generate requirements.txt content from third-party imports
  pub fn generate_requirements(&mut self, modules: &[&ModuleNode]) -> Result<String> {
    let mut third_party_imports = HashSet::new();

    for module in modules {
      self.collect_third_party_imports_from_module(module, &mut third_party_imports);
    }

    let mut requirements: Vec<String> = third_party_imports.into_iter().collect();
    requirements.sort();

    Ok(requirements.join("\n"))
  }

  /// Collect third-party imports from a single module
  fn collect_third_party_imports_from_module(
    &mut self,
    module: &ModuleNode,
    third_party_imports: &mut HashSet<String>,
  ) {
    for import in &module.imports {
      if let ImportType::ThirdParty = self.resolver.classify_import(import) {
        // Extract top-level package name
        let package_name = import.split('.').next().unwrap_or(import);
        third_party_imports.insert(package_name.to_string());
      }
    }
  }
}
