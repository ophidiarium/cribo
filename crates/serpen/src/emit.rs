use anyhow::{Context, Result};
use regex::Regex;
use rustpython_parser::Parse;
use rustpython_parser::ast::{Stmt, StmtImport, StmtImportFrom, Suite};
use std::collections::HashSet;
use std::fs;
use std::path::Path;

use crate::dependency_graph::ModuleNode;
use crate::resolver::{ImportType, ModuleResolver};

pub struct CodeEmitter {
    resolver: ModuleResolver,
    preserve_comments: bool,
    preserve_type_hints: bool,
}

impl CodeEmitter {
    pub fn new(
        resolver: ModuleResolver,
        preserve_comments: bool,
        preserve_type_hints: bool,
    ) -> Self {
        Self {
            resolver,
            preserve_comments,
            preserve_type_hints,
        }
    }

    /// Generate bundled Python code from sorted modules
    pub fn emit_bundle(&mut self, modules: &[&ModuleNode], entry_module: &str) -> Result<String> {
        let mut output = Vec::new();

        // Add header comment
        output.push("#!/usr/bin/env python3".to_string());
        output.push("# Generated by Serpen - Python Source Bundler".to_string());
        output.push("# https://github.com/tinovyatkin/serpen".to_string());
        output.push("".to_string());

        // Collect all third-party imports that need to be preserved
        let mut third_party_imports = HashSet::new();
        let mut stdlib_imports = HashSet::new();

        for module in modules {
            for import in &module.imports {
                match self.resolver.classify_import(import) {
                    ImportType::ThirdParty => {
                        third_party_imports.insert(import.clone());
                    }
                    ImportType::StandardLibrary => {
                        stdlib_imports.insert(import.clone());
                    }
                    ImportType::FirstParty => {
                        // Will be inlined, so skip
                    }
                }
            }
        }

        // Add preserved imports at the top
        if !stdlib_imports.is_empty() || !third_party_imports.is_empty() {
            output.push("# Preserved imports".to_string());

            // Standard library imports first
            let mut sorted_stdlib: Vec<_> = stdlib_imports.into_iter().collect();
            sorted_stdlib.sort();
            for import in &sorted_stdlib {
                output.push(self.format_import_statement(import));
            }

            if !sorted_stdlib.is_empty() && !third_party_imports.is_empty() {
                output.push("".to_string());
            }

            // Third-party imports
            let mut sorted_third_party: Vec<_> = third_party_imports.into_iter().collect();
            sorted_third_party.sort();
            for import in sorted_third_party {
                output.push(self.format_import_statement(&import));
            }

            output.push("".to_string());
        }

        // Process each module in dependency order
        for module in modules {
            // Skip entry module for now - we'll add it at the end
            if module.name == entry_module {
                continue;
            }

            output.push(format!("# ─ Module: {} ─", module.name));

            let module_code = self.process_module_file(&module.path, &module.name)?;
            output.push(module_code);
            output.push("".to_string());
        }

        // Add entry module last
        if let Some(entry_module_node) = modules.iter().find(|m| m.name == entry_module) {
            output.push(format!("# ─ Entry Module: {} ─", entry_module));
            let entry_code =
                self.process_module_file(&entry_module_node.path, &entry_module_node.name)?;
            output.push(entry_code);
        }

        Ok(output.join("\n"))
    }

    /// Process a single module file, removing inlined imports
    fn process_module_file(&mut self, file_path: &Path, _module_name: &str) -> Result<String> {
        let source = fs::read_to_string(file_path)
            .with_context(|| format!("Failed to read module file: {:?}", file_path))?;

        // Simple approach: process line by line and filter out first-party imports
        let mut output_lines = Vec::new();

        for line in source.lines() {
            let trimmed = line.trim();

            // Check if this is an import line
            if trimmed.starts_with("from ") && trimmed.contains(" import ") {
                // Parse "from module import ..."
                if let Some(module_part) = trimmed
                    .strip_prefix("from ")
                    .and_then(|s| s.split(" import ").next())
                {
                    let module_name = module_part.trim();
                    match self.resolver.classify_import(module_name) {
                        ImportType::FirstParty => {
                            // Skip first-party imports - they'll be inlined
                            continue;
                        }
                        ImportType::ThirdParty | ImportType::StandardLibrary => {
                            // Keep third-party and stdlib imports
                            output_lines.push(line.to_string());
                        }
                    }
                } else {
                    // Keep malformed import lines as-is
                    output_lines.push(line.to_string());
                }
            } else if trimmed.starts_with("import ") {
                // Parse "import module"
                let imports_part = trimmed.strip_prefix("import ").unwrap();
                let modules: Vec<&str> = imports_part.split(',').map(|s| s.trim()).collect();

                let mut keep_line = false;
                for module in modules {
                    // Handle "import module as alias"
                    let module_name = module.split(" as ").next().unwrap_or(module).trim();
                    match self.resolver.classify_import(module_name) {
                        ImportType::ThirdParty | ImportType::StandardLibrary => {
                            keep_line = true;
                            break;
                        }
                        ImportType::FirstParty => {
                            // Continue checking other modules in the same line
                        }
                    }
                }

                if keep_line {
                    output_lines.push(line.to_string());
                }
                // Skip lines with only first-party imports
            } else {
                // Keep all non-import lines
                output_lines.push(line.to_string());
            }
        }

        Ok(output_lines.join("\n"))
    }

    /// Process statements to remove inlined imports
    fn process_statements(&mut self, statements: &[Stmt], module_name: &str) -> Result<Vec<Stmt>> {
        let mut processed = Vec::new();

        for stmt in statements {
            match stmt {
                Stmt::Import(import_stmt) => {
                    // Check if any of the imports should be preserved
                    let mut preserved_names = Vec::new();

                    for name in &import_stmt.names {
                        let import_name = name.name.as_str();
                        match self.resolver.classify_import(import_name) {
                            ImportType::FirstParty => {
                                // Skip first-party imports - they'll be inlined
                            }
                            ImportType::ThirdParty | ImportType::StandardLibrary => {
                                preserved_names.push(name.clone());
                            }
                        }
                    }

                    // Only keep the statement if there are preserved imports
                    if !preserved_names.is_empty() {
                        let new_stmt = Stmt::Import(StmtImport {
                            names: preserved_names,
                            range: import_stmt.range.clone(),
                        });
                        processed.push(new_stmt);
                    }
                }
                Stmt::ImportFrom(import_from_stmt) => {
                    // Classify import-from by module name (ignore relative level dots)
                    let module_str = import_from_stmt.module.as_deref().unwrap_or("");
                    match self.resolver.classify_import(module_str) {
                        ImportType::FirstParty => {
                            // Skip first-party imports
                        }
                        ImportType::ThirdParty | ImportType::StandardLibrary => {
                            processed.push(stmt.clone());
                        }
                    }
                }
                _ => {
                    // Keep all other statements
                    processed.push(stmt.clone());
                }
            }
        }

        Ok(processed)
    }

    /// Convert AST statement back to string (simplified)
    fn statement_to_string(&self, stmt: &Stmt) -> Result<String> {
        // This is a simplified implementation
        // In a full implementation, you'd want to use a proper Python code formatter
        match stmt {
            Stmt::Import(import_stmt) => {
                let import_names: Vec<String> = import_stmt
                    .names
                    .iter()
                    .map(|name| {
                        if let Some(ref asname) = name.asname {
                            format!("{} as {}", name.name.as_str(), asname.as_str())
                        } else {
                            name.name.as_str().to_string()
                        }
                    })
                    .collect();
                Ok(format!("import {}", import_names.join(", ")))
            }
            Stmt::ImportFrom(import_from_stmt) => {
                // Reconstruct module part without relative level
                let module_part = import_from_stmt
                    .module
                    .as_ref()
                    .map(|m| m.as_str())
                    .unwrap_or("");

                let import_names: Vec<String> = import_from_stmt
                    .names
                    .iter()
                    .map(|name| {
                        if let Some(ref asname) = name.asname {
                            format!("{} as {}", name.name.as_str(), asname.as_str())
                        } else {
                            name.name.as_str().to_string()
                        }
                    })
                    .collect();
                Ok(format!(
                    "from {} import {}",
                    module_part,
                    import_names.join(", ")
                ))
            }
            _ => {
                // For other statements, we'd need a more sophisticated approach
                // For now, return a placeholder that indicates we need the original source
                Ok("# [Statement preserved from original source]".to_string())
            }
        }
    }

    /// Safely format an import statement, validating the input
    fn format_import_statement(&self, module_name: &str) -> String {
        // Validate that the import string looks like a simple module name
        // Module names should contain only alphanumeric characters, underscores, and dots
        if module_name
            .chars()
            .all(|c| c.is_alphanumeric() || c == '_' || c == '.')
            && !module_name.is_empty()
            && !module_name.contains(' ')
        {
            format!("import {}", module_name)
        } else {
            // If it doesn't look like a simple module name, treat it as a pre-formatted import
            // This handles cases where the import might already be formatted or contain aliases
            if module_name.starts_with("import ") || module_name.starts_with("from ") {
                module_name.to_string()
            } else {
                // Fallback: still format as import but add a comment indicating potential issue
                format!(
                    "import {}  # Warning: unusual module name format",
                    module_name
                )
            }
        }
    }

    /// Generate requirements.txt content from third-party imports
    pub fn generate_requirements(&mut self, modules: &[&ModuleNode]) -> Result<String> {
        let mut third_party_imports = HashSet::new();

        for module in modules {
            for import in &module.imports {
                if let ImportType::ThirdParty = self.resolver.classify_import(import) {
                    // Extract top-level package name
                    let package_name = import.split('.').next().unwrap_or(import);
                    third_party_imports.insert(package_name.to_string());
                }
            }
        }

        let mut requirements: Vec<String> = third_party_imports.into_iter().collect();
        requirements.sort();

        Ok(requirements.join("\n"))
    }
}
