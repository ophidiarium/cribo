use anyhow::{Context, Result};
use std::collections::{HashMap, HashSet};
use std::fs;

use crate::dependency_graph::ModuleNode;
use crate::resolver::{ImportType, ModuleResolver};
use crate::unused_imports_simple::UnusedImportAnalyzer;
use rustpython_parser::ast::{Mod, Stmt};
use rustpython_parser::{Mode, parse};

/// Type alias for import sets to reduce complexity
type ImportSets = (HashSet<String>, HashSet<String>);

/// Pre-parsed module data to eliminate redundant parsing
struct ParsedModuleData {
    source: String,
    unused_imports: HashSet<String>,
    first_party_imports: HashSet<String>,
}

/// Context for processing logical statements
struct LogicalStatementContext<'a> {
    statement: &'a str,
    first_party_imports: &'a HashSet<String>,
    unused_import_names: &'a HashSet<String>,
    output_lines: &'a mut Vec<String>,
}

pub struct CodeEmitter {
    resolver: ModuleResolver,
    _preserve_comments: bool,
    _preserve_type_hints: bool,
}

impl CodeEmitter {
    pub fn new(
        resolver: ModuleResolver,
        preserve_comments: bool,
        preserve_type_hints: bool,
    ) -> Self {
        Self {
            resolver,
            _preserve_comments: preserve_comments,
            _preserve_type_hints: preserve_type_hints,
        }
    }

    /// Helper method to classify and add import to appropriate set
    fn classify_and_add_import(
        &self,
        import: &str,
        third_party_imports: &mut HashSet<String>,
        stdlib_imports: &mut HashSet<String>,
    ) {
        match self.resolver.classify_import(import) {
            ImportType::ThirdParty => {
                third_party_imports.insert(import.to_string());
            }
            ImportType::StandardLibrary => {
                stdlib_imports.insert(import.to_string());
            }
            ImportType::FirstParty => {
                // Will be inlined, so skip
            }
        }
    }

    /// Collect imports and categorize them by type
    fn collect_import_sets(&self, modules: &[&ModuleNode]) -> ImportSets {
        let mut third_party_imports = HashSet::new();
        let mut stdlib_imports = HashSet::new();

        for module in modules {
            for import in &module.imports {
                self.classify_and_add_import(import, &mut third_party_imports, &mut stdlib_imports);
            }
        }

        (third_party_imports, stdlib_imports)
    }

    /// Generate bundled Python code from sorted modules
    pub fn emit_bundle(&mut self, modules: &[&ModuleNode], entry_module: &str) -> Result<String> {
        let mut output = vec![
            "#!/usr/bin/env python3".to_string(),
            "# Generated by Serpen - Python Source Bundler".to_string(),
            "# https://github.com/tinovyatkin/serpen".to_string(),
            "".to_string(),
        ]; // Parse all modules once and store parsed data (eliminates redundant parsing)
        let mut all_unused_imports = HashSet::new();
        let mut parsed_modules_data = HashMap::new();

        for module in modules {
            let source = fs::read_to_string(&module.path)
                .with_context(|| format!("Failed to read module file: {:?}", module.path))?;

            // Parse for unused imports analysis
            let mut unused_analyzer = UnusedImportAnalyzer::new();
            let unused_imports = unused_analyzer.analyze_file(&source).unwrap_or_else(|err| {
                log::warn!(
                    "Failed to analyze unused imports in {:?}: {}",
                    module.path,
                    err
                );
                Vec::new()
            });

            let module_unused_names: HashSet<String> = unused_imports
                .iter()
                .map(|import| import.name.clone())
                .collect();

            // Parse for first-party imports using AST (avoids redundant parsing later)
            let first_party_imports = self.collect_first_party_imports_from_source(&source)?;

            // Store parsed data for later use in process_module_file
            parsed_modules_data.insert(
                module.path.clone(),
                ParsedModuleData {
                    source,
                    unused_imports: module_unused_names.clone(),
                    first_party_imports,
                },
            );

            // Add to global set for filtering preserved imports
            for import in unused_imports {
                all_unused_imports.insert(import.name);
            }
        }

        // Collect all third-party imports that need to be preserved
        let (mut third_party_imports, mut stdlib_imports) = self.collect_import_sets(modules);

        // Filter out unused imports from preserved imports
        third_party_imports.retain(|import| !all_unused_imports.contains(import));
        stdlib_imports.retain(|import| !all_unused_imports.contains(import));

        // Add preserved imports at the top
        if !stdlib_imports.is_empty() || !third_party_imports.is_empty() {
            output.push("# Preserved imports".to_string());

            // Standard library imports first
            let mut sorted_stdlib: Vec<_> = stdlib_imports.into_iter().collect();
            sorted_stdlib.sort();
            for import in &sorted_stdlib {
                output.push(self.format_import_statement(import));
            }

            if !sorted_stdlib.is_empty() && !third_party_imports.is_empty() {
                output.push("".to_string());
            }

            // Third-party imports
            let mut sorted_third_party: Vec<_> = third_party_imports.into_iter().collect();
            sorted_third_party.sort();
            for import in sorted_third_party {
                output.push(self.format_import_statement(&import));
            }

            output.push("".to_string());
        }

        // Process each module in dependency order
        for module in modules {
            // Skip entry module for now - we'll add it at the end
            if module.name == entry_module {
                continue;
            }

            output.push(format!("# ─ Module: {} ─", module.name));

            let parsed_data = parsed_modules_data.get(&module.path).ok_or_else(|| {
                anyhow::anyhow!("Missing parsed data for module: {:?}", module.path)
            })?;

            let module_code =
                self.process_module_file_with_parsed_data(&module.name, parsed_data)?;
            output.push(module_code);
            output.push("".to_string());
        }

        // Add entry module last
        if let Some(entry_module_node) = modules.iter().find(|m| m.name == entry_module) {
            output.push(format!("# ─ Entry Module: {} ─", entry_module));

            let parsed_data = parsed_modules_data
                .get(&entry_module_node.path)
                .ok_or_else(|| {
                    anyhow::anyhow!(
                        "Missing parsed data for entry module: {:?}",
                        entry_module_node.path
                    )
                })?;

            let entry_code =
                self.process_module_file_with_parsed_data(&entry_module_node.name, parsed_data)?;
            output.push(entry_code);
        }

        Ok(output.join("\n"))
    }

    /// Process a single module using pre-parsed data, eliminating redundant file I/O and parsing
    fn process_module_file_with_parsed_data(
        &mut self,
        _module_name: &str,
        parsed_data: &ParsedModuleData,
    ) -> Result<String> {
        log::info!(
            "Processing module with {} pre-computed unused imports: {:?}",
            parsed_data.unused_imports.len(),
            parsed_data.unused_imports
        );

        // Enhanced line-based processing with triple-quote and multi-line handling
        let mut output_lines = Vec::new();
        let mut in_triple = false;
        let mut buf: Vec<String> = Vec::new();

        for line in parsed_data.source.lines() {
            // Triple-quoted string handling
            if in_triple {
                output_lines.push(line.to_string());
                in_triple = !(line.contains("'''") || line.contains("\"\"\""));
                continue;
            }

            if self.is_triple_quote_start(line) {
                in_triple = true;
                output_lines.push(line.to_string());
                continue;
            }

            // Accumulate logical lines (handle backslash continuations and unmatched parentheses)
            buf.push(line.to_string());
            let joined = buf.join("\n");

            if self.is_statement_continuation(&joined, line) {
                continue;
            }

            // Logical statement ready - process it
            self.process_logical_statement(LogicalStatementContext {
                statement: &joined,
                first_party_imports: &parsed_data.first_party_imports,
                unused_import_names: &parsed_data.unused_imports,
                output_lines: &mut output_lines,
            });
            buf.clear();
        }

        // Flush any remaining buffer
        for line in buf {
            output_lines.push(line);
        }

        Ok(output_lines.join("\n"))
    }

    /// Collect first-party imports from source code using AST parsing
    fn collect_first_party_imports_from_source(&self, source: &str) -> Result<HashSet<String>> {
        let mut first_party_imports = HashSet::new();

        match parse(source, Mode::Module, "module") {
            Ok(Mod::Module(module)) => {
                for stmt in &module.body {
                    self.collect_first_party_from_statement(stmt, &mut first_party_imports);
                }
            }
            Ok(_) => {
                log::warn!("Unexpected AST node type when parsing module");
            }
            Err(e) => {
                log::warn!("Failed to parse module for first-party imports: {}", e);
                // Continue with empty set rather than failing the entire bundling
            }
        }

        log::debug!("Collected first-party imports: {:?}", first_party_imports);
        Ok(first_party_imports)
    }

    /// Extract first-party imports from an AST statement
    fn collect_first_party_from_statement(&self, stmt: &Stmt, imports: &mut HashSet<String>) {
        match stmt {
            Stmt::Import(import_stmt) => {
                self.collect_first_party_from_import(import_stmt, imports);
            }
            Stmt::ImportFrom(import_from_stmt) => {
                self.collect_first_party_from_import_from(import_from_stmt, imports);
            }
            _ => {}
        }
    }

    /// Helper to collect first-party imports from "from ... import" statements
    fn collect_first_party_from_import_from(
        &self,
        import_from_stmt: &rustpython_parser::ast::StmtImportFrom,
        imports: &mut HashSet<String>,
    ) {
        // Handle relative imports (e.g., `from . import x`) as first-party
        if import_from_stmt.module.is_none() {
            if import_from_stmt.level.is_some() {
                // Insert empty string marker for relative import
                imports.insert(String::new());
            }
            return;
        }
        let module = import_from_stmt.module.as_ref().unwrap();

        let module_name = module.as_str();
        if matches!(
            self.resolver.classify_import(module_name),
            ImportType::FirstParty
        ) {
            imports.insert(module_name.to_string());
        }
    }

    /// Helper to collect first-party imports from regular import statements
    fn collect_first_party_from_import(
        &self,
        import_stmt: &rustpython_parser::ast::StmtImport,
        imports: &mut HashSet<String>,
    ) {
        for alias in &import_stmt.names {
            let import_name = alias.name.as_str();
            if matches!(
                self.resolver.classify_import(import_name),
                ImportType::FirstParty
            ) {
                imports.insert(import_name.to_string());
            }
        }
    }

    /// Check if a line starts a triple-quoted string (multi-line)
    fn is_triple_quote_start(&self, line: &str) -> bool {
        let trimmed = line.trim_start();

        // Check for triple quotes
        if trimmed.starts_with("'''") {
            // Count occurrences of ''' in the line
            let count = trimmed.matches("'''").count();
            // If there's only one occurrence, it's the start of a multi-line string
            return count == 1;
        }

        if trimmed.starts_with("\"\"\"") {
            // Count occurrences of """ in the line
            let count = trimmed.matches("\"\"\"").count();
            // If there's only one occurrence, it's the start of a multi-line string
            return count == 1;
        }

        false
    }

    /// Check if the current statement should be continued (backslash or unmatched parentheses)
    fn is_statement_continuation(&self, joined: &str, last_line: &str) -> bool {
        if last_line.trim_end().ends_with('\\') {
            return true;
        }

        let open_paren = joined.matches('(').count();
        let close_paren = joined.matches(')').count();
        open_paren > close_paren
    }

    /// Process a complete logical statement
    fn process_logical_statement(&self, ctx: LogicalStatementContext) {
        let trimmed = ctx.statement.trim();
        let is_import = trimmed.starts_with("import ")
            || (trimmed.starts_with("from ") && trimmed.contains(" import "));

        if !is_import {
            // Non-import: emit original text
            ctx.output_lines
                .extend(ctx.statement.lines().map(str::to_string));
            return;
        }

        // Check if all modules in this import are first-party; if so, skip
        let modules = self.extract_import_modules(trimmed);
        log::debug!(
            "Processing import statement: '{}', extracted modules: {:?}",
            trimmed,
            modules
        );

        let all_first_party = modules
            .iter()
            .all(|module_name| ctx.first_party_imports.contains(module_name));

        // Check if any of the imported names are unused
        let contains_unused =
            self.check_if_import_contains_unused(trimmed, ctx.unused_import_names);

        log::debug!(
            "All modules first-party: {}, contains unused: {}, first_party_imports: {:?}",
            all_first_party,
            contains_unused,
            ctx.first_party_imports
        );

        if all_first_party {
            // Skip statements with only first-party imports
            log::debug!("Skipping import (all first-party): {}", trimmed);
        } else if contains_unused {
            // Rewrite import statement to remove unused imports
            if let Some(rewritten) =
                self.rewrite_import_without_unused(trimmed, ctx.unused_import_names)
            {
                // Capture the leading whitespace from the original statement safely
                let original_indent: String = ctx
                    .statement
                    .chars()
                    .take_while(|c| c.is_whitespace())
                    .collect();

                // Prepend the original indentation to the rewritten statement
                let indented_rewritten = format!("{}{}", original_indent, rewritten);
                ctx.output_lines.push(indented_rewritten);
            }
        } else {
            // Preserve statement if it contains non-first-party imports and no unused imports
            ctx.output_lines
                .extend(ctx.statement.lines().map(str::to_string));
        }
    }

    /// Rewrite an import statement to remove only unused imports while preserving used ones
    /// Returns None if all imports are unused (statement should be skipped)
    /// Returns Some(rewritten_statement) if any imports are still used
    fn rewrite_import_without_unused(
        &self,
        statement: &str,
        unused_import_names: &HashSet<String>,
    ) -> Option<String> {
        let trimmed = statement.trim();

        // Handle inline comments - split statement and comment parts
        let (import_part, comment_part) = if let Some(comment_pos) = trimmed.find('#') {
            let import_text = trimmed[..comment_pos].trim();
            let comment_text = &trimmed[comment_pos..];
            (import_text, Some(comment_text))
        } else {
            (trimmed, None)
        };

        if import_part.starts_with("from ") && import_part.contains(" import ") {
            self.rewrite_from_import(import_part, comment_part, unused_import_names)
        } else if let Some(imports_part) = import_part.strip_prefix("import ") {
            self.rewrite_simple_import(imports_part, comment_part, unused_import_names)
        } else {
            // Not a recognized import format, preserve as-is
            Some(statement.to_string())
        }
    }

    /// Rewrite a "from module import ..." statement
    fn rewrite_from_import(
        &self,
        import_part: &str,
        comment_part: Option<&str>,
        unused_import_names: &HashSet<String>,
    ) -> Option<String> {
        let module_and_imports = import_part.strip_prefix("from ")?;
        let (module_part, imports_part) = module_and_imports.split_once(" import ")?;

        let used_imports = self.filter_used_imports(imports_part, unused_import_names);

        if used_imports.is_empty() {
            return None; // All imports are unused
        }

        let mut result = format!(
            "from {} import {}",
            module_part.trim(),
            used_imports.join(", ")
        );
        self.append_comment_if_present(&mut result, comment_part);
        Some(result)
    }

    /// Rewrite a simple "import ..." statement
    fn rewrite_simple_import(
        &self,
        imports_part: &str,
        comment_part: Option<&str>,
        unused_import_names: &HashSet<String>,
    ) -> Option<String> {
        let used_imports = self.filter_used_imports(imports_part, unused_import_names);

        if used_imports.is_empty() {
            return None; // All imports are unused
        }

        let mut result = format!("import {}", used_imports.join(", "));
        self.append_comment_if_present(&mut result, comment_part);
        Some(result)
    }

    /// Append comment to result string if present
    fn append_comment_if_present(&self, result: &mut String, comment_part: Option<&str>) {
        if let Some(comment) = comment_part {
            result.push_str("  ");
            result.push_str(comment);
        }
    }

    /// Filter out unused imports from a comma-separated list, preserving used ones with their aliases and spacing
    fn filter_used_imports(
        &self,
        imports_part: &str,
        unused_import_names: &HashSet<String>,
    ) -> Vec<String> {
        imports_part
            .split(',')
            .filter_map(|import_item| {
                let trimmed_item = import_item.trim();
                let import_name = self.extract_import_name(trimmed_item);

                // Keep this import if it's not in the unused set
                if !unused_import_names.contains(&import_name) {
                    Some(trimmed_item.to_string())
                } else {
                    None
                }
            })
            .collect()
    }

    /// Extract module names from an import statement
    fn extract_import_modules(&self, statement: &str) -> Vec<String> {
        if statement.starts_with("from ") {
            return self.extract_from_import_module(statement);
        }

        if let Some(imports_part) = statement.strip_prefix("import ") {
            return imports_part
                .split(',')
                .map(|import_item| self.extract_original_module_name(import_item))
                .collect();
        }

        vec![]
    }

    /// Extract module name from a "from ... import" statement
    ///
    /// Inspired by ruff's import parsing patterns:
    /// https://github.com/astral-sh/ruff/tree/main/crates/ruff_python_parser/src/parser/statement.rs
    fn extract_from_import_module(&self, statement: &str) -> Vec<String> {
        let module_part = statement
            .strip_prefix("from ")
            .and_then(|s| s.split(" import ").next());

        let Some(module_part) = module_part else {
            return vec![];
        };

        // Strip comments from module name
        let clean_module = module_part.split('#').next().unwrap_or(module_part).trim();

        // Handle relative imports: "." becomes empty string
        let normalized_module = if clean_module == "." {
            ""
        } else {
            clean_module
        };

        vec![normalized_module.to_string()]
    }

    /// Extract import name from an import item, handling comments and aliases
    /// Returns the alias name if present (what the import is known as in the code),
    /// otherwise returns the original module name
    fn extract_import_name(&self, import_item: &str) -> String {
        // Strip comments first
        let clean_item = import_item.split('#').next().unwrap_or(import_item);

        // If there's an alias (import X as Y), return the alias name (Y)
        // Otherwise return the original name (X)
        if let Some(as_pos) = clean_item.find(" as ") {
            clean_item[as_pos + 4..].trim().to_string()
        } else {
            clean_item.trim().to_string()
        }
    }

    /// Extract the original module name from an import item, handling comments and aliases
    /// Returns the original module name (the part before 'as' if present),
    /// which is needed for first-party detection
    fn extract_original_module_name(&self, import_item: &str) -> String {
        // Strip comments first
        let clean_item = import_item.split('#').next().unwrap_or(import_item);

        // If there's an alias (import X as Y), return the original name (X)
        // Otherwise return the name as-is (X)
        if let Some(as_pos) = clean_item.find(" as ") {
            clean_item[..as_pos].trim().to_string()
        } else {
            clean_item.trim().to_string()
        }
    }

    /// Check if import parts contain any unused names
    fn has_unused_import_in_parts(
        &self,
        imports_part: &str,
        unused_import_names: &HashSet<String>,
    ) -> bool {
        imports_part.split(',').any(|import_item| {
            let name = self.extract_import_name(import_item);
            unused_import_names.contains(&name)
        })
    }

    /// Check if an import statement contains any unused imported names
    fn check_if_import_contains_unused(
        &self,
        statement: &str,
        unused_import_names: &HashSet<String>,
    ) -> bool {
        if statement.starts_with("from ") && statement.contains(" import ") {
            // Handle "from module import name1, name2" statements
            if let Some(imports_part) = statement.split(" import ").nth(1) {
                return self.has_unused_import_in_parts(imports_part, unused_import_names);
            }
        } else if let Some(imports_part) = statement.strip_prefix("import ") {
            // Handle "import module1, module2" statements
            return self.has_unused_import_in_parts(imports_part, unused_import_names);
        }

        false
    }

    /// Check if a module name is valid (alphanumeric, underscores, dots only)
    fn is_valid_module_name(&self, module_name: &str) -> bool {
        !module_name.is_empty()
            && !module_name.contains(' ')
            && module_name
                .chars()
                .all(|c| c.is_alphanumeric() || c == '_' || c == '.')
    }

    /// Safely format an import statement, validating the input
    fn format_import_statement(&self, module_name: &str) -> String {
        if self.is_valid_module_name(module_name) {
            return format!("import {}", module_name);
        }

        // If it doesn't look like a simple module name, treat it as a pre-formatted import
        // This handles cases where the import might already be formatted or contain aliases
        if module_name.starts_with("import ") || module_name.starts_with("from ") {
            module_name.to_string()
        } else {
            // Fallback: still format as import but add a comment indicating potential issue
            format!(
                "import {}  # Warning: unusual module name format",
                module_name
            )
        }
    }

    /// Generate requirements.txt content from third-party imports
    pub fn generate_requirements(&mut self, modules: &[&ModuleNode]) -> Result<String> {
        let mut third_party_imports = HashSet::new();

        for module in modules {
            self.collect_third_party_imports_from_module(module, &mut third_party_imports);
        }

        let mut requirements: Vec<String> = third_party_imports.into_iter().collect();
        requirements.sort();

        Ok(requirements.join("\n"))
    }

    /// Collect third-party imports from a single module
    fn collect_third_party_imports_from_module(
        &mut self,
        module: &ModuleNode,
        third_party_imports: &mut HashSet<String>,
    ) {
        for import in &module.imports {
            if let ImportType::ThirdParty = self.resolver.classify_import(import) {
                // Extract top-level package name
                let package_name = import.split('.').next().unwrap_or(import);
                third_party_imports.insert(package_name.to_string());
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::Config;
    use std::collections::HashSet;

    fn create_test_emitter() -> CodeEmitter {
        let config = Config::default();
        let resolver = ModuleResolver::new(config).unwrap();
        CodeEmitter::new(resolver, false, false)
    }

    #[test]
    fn test_rewrite_simple_import_with_unused() {
        let emitter = create_test_emitter();
        let mut unused = HashSet::new();
        unused.insert("sys".to_string());

        let result = emitter.rewrite_import_without_unused("import os, sys", &unused);
        assert_eq!(result, Some("import os".to_string()));
    }

    #[test]
    fn test_rewrite_from_import_with_unused() {
        let emitter = create_test_emitter();
        let mut unused = HashSet::new();
        unused.insert("Counter".to_string());

        let result = emitter
            .rewrite_import_without_unused("from collections import defaultdict, Counter", &unused);
        assert_eq!(
            result,
            Some("from collections import defaultdict".to_string())
        );
    }

    #[test]
    fn test_rewrite_import_all_unused() {
        let emitter = create_test_emitter();
        let mut unused = HashSet::new();
        unused.insert("os".to_string());
        unused.insert("sys".to_string());

        let result = emitter.rewrite_import_without_unused("import os, sys", &unused);
        assert_eq!(result, None);
    }

    #[test]
    fn test_rewrite_import_with_comment() {
        let emitter = create_test_emitter();
        let mut unused = HashSet::new();
        unused.insert("sys".to_string());

        let result =
            emitter.rewrite_import_without_unused("import os, sys  # System imports", &unused);
        assert_eq!(result, Some("import os  # System imports".to_string()));
    }

    #[test]
    fn test_rewrite_from_import_with_comment() {
        let emitter = create_test_emitter();
        let mut unused = HashSet::new();
        unused.insert("PurePath".to_string());

        let result = emitter.rewrite_import_without_unused(
            "from pathlib import Path, PurePath  # Path utilities",
            &unused,
        );
        assert_eq!(
            result,
            Some("from pathlib import Path  # Path utilities".to_string())
        );
    }

    #[test]
    fn test_rewrite_import_none_unused() {
        let emitter = create_test_emitter();
        let unused = HashSet::new(); // No unused imports

        let result = emitter.rewrite_import_without_unused("import os, sys", &unused);
        assert_eq!(result, Some("import os, sys".to_string()));
    }

    #[test]
    fn test_rewrite_import_with_aliases() {
        let emitter = create_test_emitter();
        let mut unused = HashSet::new();
        unused.insert("pd".to_string()); // pandas alias is unused

        let result =
            emitter.rewrite_import_without_unused("import numpy as np, pandas as pd", &unused);
        assert_eq!(result, Some("import numpy as np".to_string()));
    }

    #[test]
    fn test_extract_import_modules_with_aliases() {
        let emitter = create_test_emitter();

        // Test regular imports without aliases
        let result = emitter.extract_import_modules("import os, sys");
        assert_eq!(result, vec!["os", "sys"]);

        // Test imports with aliases - should return original module names, not aliases
        let result = emitter.extract_import_modules("import numpy as np, pandas as pd");
        assert_eq!(result, vec!["numpy", "pandas"]);

        // Test mixed imports with and without aliases
        let result = emitter.extract_import_modules("import os, numpy as np, sys");
        assert_eq!(result, vec!["os", "numpy", "sys"]);

        // Test single import with alias
        let result = emitter.extract_import_modules("import matplotlib.pyplot as plt");
        assert_eq!(result, vec!["matplotlib.pyplot"]);

        // Test from imports (should not be affected by the fix)
        let result = emitter.extract_import_modules("from collections import defaultdict");
        assert_eq!(result, vec!["collections"]);

        // Test from imports with complex module path
        let result = emitter.extract_import_modules("from package.submodule import func");
        assert_eq!(result, vec!["package.submodule"]);

        // Test imports with comments
        let result = emitter.extract_import_modules("import requests as req  # HTTP library");
        assert_eq!(result, vec!["requests"]);

        // Test empty import statement
        let result = emitter.extract_import_modules("");
        assert_eq!(result, Vec::<String>::new());

        // Test malformed import
        let result = emitter.extract_import_modules("invalid import statement");
        assert_eq!(result, Vec::<String>::new());
    }

    #[test]
    fn test_extract_original_module_name() {
        let emitter = create_test_emitter();

        // Test without alias
        assert_eq!(emitter.extract_original_module_name("numpy"), "numpy");

        // Test with alias
        assert_eq!(emitter.extract_original_module_name("numpy as np"), "numpy");

        // Test with complex module name and alias
        assert_eq!(
            emitter.extract_original_module_name("matplotlib.pyplot as plt"),
            "matplotlib.pyplot"
        );

        // Test with comment
        assert_eq!(
            emitter.extract_original_module_name("requests as req  # HTTP lib"),
            "requests"
        );

        // Test with whitespace
        assert_eq!(
            emitter.extract_original_module_name("  pandas   as   pd  "),
            "pandas"
        );

        // Test extract_import_name for comparison (should return alias when present)
        assert_eq!(emitter.extract_import_name("numpy as np"), "np");
        assert_eq!(emitter.extract_import_name("numpy"), "numpy");
    }

    #[test]
    fn test_process_logical_statement_preserves_indentation() {
        let emitter = create_test_emitter();
        let first_party_imports = HashSet::new();

        // Test with 4-space indentation (common in function bodies)
        {
            let mut output_lines = Vec::new();
            let mut unused_imports = HashSet::new();
            unused_imports.insert("sys".to_string());

            let ctx = LogicalStatementContext {
                statement: "    import os, sys  # Test comment",
                first_party_imports: &first_party_imports,
                unused_import_names: &unused_imports,
                output_lines: &mut output_lines,
            };

            emitter.process_logical_statement(ctx);

            // Should preserve the 4-space indentation
            assert_eq!(output_lines.len(), 1);
            assert_eq!(output_lines[0], "    import os  # Test comment");
        }

        // Test with tab indentation
        {
            let mut output_lines = Vec::new();
            let mut unused_imports = HashSet::new();
            unused_imports.insert("Counter".to_string());

            let ctx = LogicalStatementContext {
                statement: "\tfrom collections import Counter, defaultdict",
                first_party_imports: &first_party_imports,
                unused_import_names: &unused_imports,
                output_lines: &mut output_lines,
            };

            emitter.process_logical_statement(ctx);

            // Should preserve the tab indentation
            assert_eq!(output_lines.len(), 1);
            assert_eq!(output_lines[0], "\tfrom collections import defaultdict");
        }

        // Test with no indentation (top-level import)
        {
            let mut output_lines = Vec::new();
            let mut unused_imports = HashSet::new();
            unused_imports.insert("pathlib".to_string());

            let ctx = LogicalStatementContext {
                statement: "import json, pathlib",
                first_party_imports: &first_party_imports,
                unused_import_names: &unused_imports,
                output_lines: &mut output_lines,
            };

            emitter.process_logical_statement(ctx);

            // Should have no leading whitespace
            assert_eq!(output_lines.len(), 1);
            assert_eq!(output_lines[0], "import json");
        }

        // Test with mixed spaces and tabs (8 spaces + 1 tab)
        {
            let mut output_lines = Vec::new();
            let mut unused_imports = HashSet::new();
            unused_imports.insert("typing".to_string());

            let ctx = LogicalStatementContext {
                statement: "        \timport typing, collections",
                first_party_imports: &first_party_imports,
                unused_import_names: &unused_imports,
                output_lines: &mut output_lines,
            };

            emitter.process_logical_statement(ctx);

            // Should preserve the exact whitespace pattern
            assert_eq!(output_lines.len(), 1);
            assert_eq!(output_lines[0], "        \timport collections");
        }
    }
}
